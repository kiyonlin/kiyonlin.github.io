(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{241:function(t,e,i){"use strict";i.r(e);var _=i(2),s=Object(_.a)({},function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("div",{staticClass:"content"},[i("p",[t._v("原文"),i("a",{attrs:{href:"http://linux.vbird.org/linux_basic/0130designlinux.php",target:"_blank",rel:"noopener noreferrer"}},[t._v("鸟哥的 Linux私房菜 第二章、主機規劃與磁碟分割"),i("OutboundLink")],1)]),t._v(" "),t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),i("p",[t._v("由于分区表所在区块仅有64 bytes容量，因此最多仅能有四组记录区，每组记录区记录了该区段的启始与结束的磁柱号码。 这四个分区的记录被称为主要(Primary)或扩展(Extended)分区。")]),t._v(" "),t._m(10),t._v(" "),i("p",[t._v("在Windows/Linux系统中，我们通过扩展分区(Extended)的方式来处理更多的分区！扩展分区的想法是：利用额外的磁区来记录更多的分区信息，扩展分区并不是只占一个区块，而是分布在每个分区的最前面几个磁区来记载分区信息！由扩展分区继续切出来的分区，就被称为逻辑分区(logical partition)。逻辑分区的设备名称号码一般由5号开始，前4个是主分区或者扩展分区。")]),t._v(" "),i("p",[t._v("MBR 主分区、扩展分区与逻辑分区的特性：")]),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),i("p",[t._v("因为过去一个磁区大小就是512bytes 而已，不过目前已经有4K 的磁区设计出现！为了相容于所有的磁盘，因此在磁区的定义上面， 大多会使用所谓的逻辑区块位址(Logical Block Address, LBA)来处理。GPT 将磁盘所有区块以此LBA(预设为512bytes ！) 来规划，而第一个 LBA 称为LBA0 (从0 开始编号)。")]),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),i("p",[t._v("现在GPT 分区预设可以提供多达128 笔纪录，而在Linux 本身的核心设备纪录中，针对单一磁盘来说，虽然过去最多只能到达15 个分区，不过由于Linux kernel 透过udev 等方式的处理，现在Linux 也已经没有这个限制在了！此外，GPT 分区已经没有所谓的主、扩展、逻辑分区的概念，既然每笔纪录都可以独立存在， 当然每个都可以视为是主分区！每一个分区都可以拿来格式化使用！")]),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),i("p",[t._v("第二点要注意，如果分区表为GPT 格式的话，那么BIOS 也能够从LBA0 的MBR 相容区块读取第一阶段的开机管理程序码， 如果开机管理程序能够认识GPT 的话，那么使用BIOS 同样可以读取到正确的操作系统核心！换句话说， 如果开机管理程序不懂GPT ，例如Windows XP 的环境，那自然就无法读取核心文件，开机就失败了！")]),t._v(" "),i("p",[t._v("boot loader的主要任务有：")]),t._v(" "),t._m(20),t._v(" "),t._m(21),t._v(" "),i("p",[t._v("UEFI(Unified Extensible Firmware Interface，统一可扩展固件接口)主要是想要取代BIOS 这个固件界面。如果开发者够厉害，可以在UEFI 开机阶段就让该系统了解TCP/IP 而直接上网。")]),t._v(" "),t._m(22),t._v(" "),i("p",[t._v("由于过去cracker经常藉由BIOS开机阶段来破坏系统，并取得系统的控制权，因此UEFI加入了一个所谓的安全启动(secure boot)机制，这个机制代表着即将开机的操作系统必须要被UEFI所验证，否则就无法顺利开机！微软用了很多这样的机制来管理硬件。不过加入这个机制后，许多的操作系统，包括Linux ，就很有可能无法顺利开机！所以，某些时刻，可能得要将UEFI的secure boot功能关闭，才能够顺利的进入Linux。")]),t._v(" "),t._m(23),t._v(" "),t._m(24),t._v(" "),i("p",[t._v("所谓的『挂载』就是利用一个目录当成进入点，将磁盘分区的资料放置在该目录下；也就是说，进入该目录就可以读取该分区的意思。这个动作称为『挂载』，那个进入点的目录称为『挂载点』。由于整个Linux系统最重要的是根目录，因此根目录一定需要挂载到某个分区的。")]),t._v(" "),t._m(25),t._v(" "),t._m(26)])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"linux和硬件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#linux和硬件","aria-hidden":"true"}},[this._v("#")]),this._v(" Linux和硬件")])},function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("table",[i("thead",[i("tr",[i("th",{staticStyle:{"text-align":"left"}},[t._v("设备")]),t._v(" "),i("th",{staticStyle:{"text-align":"left"}},[t._v("设备在Linux内的文件名")])])]),t._v(" "),i("tbody",[i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("SCSI/SATA/USB硬盘")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("/dev/sd[ap]")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("USB")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("/dev/sd[ap] (与SATA相同)")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("VirtI/O")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("/dev/vd[ap] (用于虚拟机器内)")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("软盘")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("/dev/fd[0-1]")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("打印机")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("/dev/lp[0-2] (25针打印机)、/dev/usb/lp[0-15] (USB接口)")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("鼠标")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("/dev/input/mouse[0-15] (通用)、/dev/psaux (PS/2接口)、/dev/mouse (当前鼠标)")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("CDROM/DVDROM")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("/dev/scd[0-1] (通用) 、/dev/sr[0-1] (通用，CentOS较常见) 、/dev/cdrom (当前CDROM)")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("磁带机")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("/dev/ht0 (IDE接口) 、/dev/st0 (SATA/SCSI接口) 、/dev/tape (当前磁带)")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("IDE硬盘机")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("/dev/hd[ad] (旧式系统才有)")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"磁盘分区"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#磁盘分区","aria-hidden":"true"}},[this._v("#")]),this._v(" 磁盘分区")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"磁盘连接的方式和设备文件名的关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#磁盘连接的方式和设备文件名的关系","aria-hidden":"true"}},[this._v("#")]),this._v(" 磁盘连接的方式和设备文件名的关系")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("正常的实体机器大概使用的都是/dev/sd[a-]的设备文件名，至于虚拟机器环境底下，为了加速，可能就会使用/dev/vd[ap]这种设备文件名！")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("由于SATA/USB/SAS等磁盘接口都是使用SCSI模组来驱动的，因此这些接口的设备文件名都是/dev/sd[ap]的格式。所以SATA/USB接口的磁盘根本就没有一定的顺序，那如何决定他的设备文件名呢？这个时候就得要"),e("strong",[this._v("根据Linux核心检测到磁盘的顺序")]),this._v("了！")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("em",[e("strong",[this._v("例题：")])]),this._v("\n如果你的PC上面有两个SATA磁盘以及一个USB磁盘，而主机板上面有六个SATA的插槽。这两个SATA磁盘分别安插在主机板上的SATA1, SATA5插槽上， 请问这三个磁盘在Linux中的设备文件名为何？\n"),e("em",[e("strong",[this._v("答：")])]),this._v("\n由于是使用检测到的顺序来决定设备文件名，并非与实际插槽代号有关，因此设备文件名如下：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("SATA1插槽上的文件名：/dev/sda")]),this._v(" "),e("li",[this._v("SATA5插槽上的文件名：/dev/sdb")]),this._v(" "),e("li",[this._v("USB磁盘(开机完成后才被系统捉到)：/dev/sdc")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"msdos-mbr-分区表格式与限制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#msdos-mbr-分区表格式与限制","aria-hidden":"true"}},[this._v("#")]),this._v(" MSDOS (MBR) 分区表格式与限制")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("主要开机记录区(Master Boot Record, MBR)：可以安装开机管理程序的地方，有446 bytes")]),this._v(" "),e("li",[this._v("分区表(partition table)：记录整颗硬盘分区的状态，有64 bytes")])])},function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ul",[i("li",[t._v("其实所谓的『分区』只是针对那个64 bytes的分区表进行设定而已！")]),t._v(" "),i("li",[t._v("硬盘预设的分区表仅能写入四组分区信息")]),t._v(" "),i("li",[t._v("这四组分区信息我们称为主要(Primary)或扩展(Extended)分区")]),t._v(" "),i("li",[t._v("分区的最小单位『通常』为磁柱(cylinder)")]),t._v(" "),i("li",[t._v("当系统要写入磁盘时，一定会参考磁盘分区表，才能针对某个分区进行资料的处理")])])},function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ul",[i("li",[t._v("主要分区与扩展分区最多可以有四个(硬盘的限制)；")]),t._v(" "),i("li",[t._v("扩展分区最多只能有一个(操作系统的限制)；")]),t._v(" "),i("li",[t._v("逻辑分区是由扩展分区持续切割出来的分区；")]),t._v(" "),i("li",[t._v("能够被格式化后，作为资料存取的分区为主要分区与逻辑分区。扩展分区无法格式化；")]),t._v(" "),i("li",[t._v("逻辑分区的数量依操作系统而不同，在Linux系统中SATA硬盘已经可以突破63个以上的分区限制。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("如果扩展分区被破坏，所有逻辑分区将会被删除。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"guid-partition-table-gpt磁盘分区表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#guid-partition-table-gpt磁盘分区表","aria-hidden":"true"}},[this._v("#")]),this._v(" GUID partition table, GPT磁盘分区表")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("与MBR仅使用第一个512bytes区块来纪录不同， GPT使用了34个LBA区块来纪录分区信息！同时与过去MBR仅有一的区块，被干掉就死光光的情况不同， GPT除了前面34个LBA之外，整个磁盘的最后33个LBA也拿来作为另一个备份！详细的结构有点像底下的模样：\n"),e("img",{attrs:{src:"http://linux.vbird.org/linux_basic/0130designlinux/gpt_partition_1.jpg",alt:"GPT 分区表的结构示意图"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("LBA0 (MBR 相容区块)")]),this._v("\n与MBR模式相似的，这个相容区块也分为两个部份，一个就是跟之前446 bytes相似的区块，储存了第一阶段的开机管理程序！而在原本的分区表的纪录区内，这个相容模式仅放入一个特殊标志的分区，用来表示此磁盘为GPT格式之意。而不懂GPT分区表的磁盘管理程序，就不会认识这颗磁盘，除非用户有特别要求要处理这颗磁盘，否则该管理软件不能修改此分区信息，进一步保护了此磁盘喔！")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("LBA1 (GPT 表头纪录)")]),this._v("\n这个部份纪录了分区表本身的位置与大小，同时纪录了备份用的GPT 分区(就是前面谈到的在最后34 个LBA 区块) 放置的位置， 同时放置了分区表的检验机制码(CRC32 )，操作系统可以根据这个检验码来判断GPT 是否正确。若有错误，还可以透过这个纪录区来取得备份的GPT(磁盘最后的那个备份区块) 来恢复GPT 的正常运作！")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("LBA2-33 (实际纪录分区信息处)")]),this._v("\n从LBA2区块开始，每个LBA都可以纪录4笔分区纪录，所以在预设的情况下，总共可以有4*32 = 128笔分区纪录喔！因为每个LBA有512bytes，因此每笔纪录用到128 bytes的空间，除了每笔纪录所需要的识别码与相关的纪录之外，GPT在每笔纪录中分别提供了64bits来记载开始/结束的磁区号码，因此，GPT分区表对于单一分区来说，他的最大容量限制就会在『 2^64 * 512bytes = 2^63 * 1Kbytes = 2^33 *TB = 8 ZB 』，要注意1ZB = 2^30 TB。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"bios-搭配mbr-gpt-的开机流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bios-搭配mbr-gpt-的开机流程","aria-hidden":"true"}},[this._v("#")]),this._v(" BIOS 搭配MBR/GPT 的开机流程")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("BIOS：开机主动执行的固件，会认识第一个可开机的设备；")]),this._v(" "),e("li",[this._v("MBR：第一个可开机设备的第一个磁区内的主要开机记录区块，内含开机管理程序；")]),this._v(" "),e("li",[this._v("开机管理程序(boot loader)：可读取核心文件来执行的软件；")]),this._v(" "),e("li",[this._v("核心文件：开始操作系统的功能...")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("提供选单：使用者可以选择不同的开机项目，这也是多重开机的重要功能！")]),this._v(" "),e("li",[this._v("载入核心文件：直接指向可开机的程序区段来开始操作系统；")]),this._v(" "),e("li",[this._v("转交其他loader：将开机管理功能转交给其他loader负责。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"uefi-bios搭配gpt开机的流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#uefi-bios搭配gpt开机的流程","aria-hidden":"true"}},[this._v("#")]),this._v(" UEFI BIOS搭配GPT开机的流程")])},function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("table",[i("thead",[i("tr",[i("th",{staticStyle:{"text-align":"left"}},[t._v("比较项目")]),t._v(" "),i("th",{staticStyle:{"text-align":"left"}},[t._v("传统BIOS")]),t._v(" "),i("th",{staticStyle:{"text-align":"left"}},[t._v("UEFI")])])]),t._v(" "),i("tbody",[i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("使用程序语言")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("组合语言")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("C语言")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("硬件资源控制")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("使用中断(IRQ)管理、不可变的记忆体存取、不可变的输入/输出存取")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("使用驱动程序与协议")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("处理器运行环境")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("16位")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("CPU保护模式")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("扩充方式")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("通过IRQ连结")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("直接载入驱动程序")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("第三方厂商支持")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("较差")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("较佳且可支持多平台")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("图形化能力")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("较差")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("较佳")])]),t._v(" "),i("tr",[i("td",{staticStyle:{"text-align":"left"}},[t._v("内建简化操作系统前环境")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("不支持")]),t._v(" "),i("td",{staticStyle:{"text-align":"left"}},[t._v("支持")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"linux安装模式下，磁盘分区的选择-极重要"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#linux安装模式下，磁盘分区的选择-极重要","aria-hidden":"true"}},[this._v("#")]),this._v(" Linux安装模式下，磁盘分区的选择("),e("strong",[this._v("极重要")]),this._v(")")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"文件系统与目录树的关系-挂载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文件系统与目录树的关系-挂载","aria-hidden":"true"}},[this._v("#")]),this._v(" 文件系统与目录树的关系(挂载)")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"重点回顾"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#重点回顾","aria-hidden":"true"}},[this._v("#")]),this._v(" 重点回顾")])},function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ul",[i("li",[t._v("在Linux系统中，每个设备都被当成一个文件来对待，每个设备都会有设备文件名。")]),t._v(" "),i("li",[t._v("磁盘设备文件名通常分为两种，实际SATA/USB设备文件名为/dev/sd[ap]，而虚拟机的设备可能为/dev/vd[ap]")]),t._v(" "),i("li",[t._v("磁盘的第一个磁区主要记录了两个重要的信息，分别是： (1)主要开机记录区(Master Boot Record, MBR)：可以安装开机管理程序的地方，有446 bytes (1)分区表(partition table)：记录整颗硬盘分区的状态，有64 bytes；")]),t._v(" "),i("li",[t._v("磁盘的MBR 分区方式中，主要与扩展分区最多可以有四个，逻辑分区的设备文件名号码，一定由5号开始；")]),t._v(" "),i("li",[t._v("如果磁盘容量大于2TB 以上时，系统会自动使用GPT 分区方式来处理磁盘分区。")]),t._v(" "),i("li",[t._v("GPT 分区已经没有扩展与逻辑分区的概念，所有的分区都是主分区！")]),t._v(" "),i("li",[t._v("某些操作系统要使用GPT 分区时，必须要搭配UEFI 的新型BIOS 格式才可安装使用。")]),t._v(" "),i("li",[t._v("开机的流程由：BIOS--\x3eMBR--\x3eboot loader--\x3e核心文件；")]),t._v(" "),i("li",[t._v("boot loader的功能主要有：提供选单、载入核心、转交控制权给其他loader")]),t._v(" "),i("li",[t._v("boot loader可以安装的地点有两个，分别是MBR 与boot sector")]),t._v(" "),i("li",[t._v("Linux操作系统的文件使用目录树系统，与磁盘的对应需要有『挂载』的动作才行；")]),t._v(" "),i("li",[t._v("新手的简单分区，建议只要有/及swap两个分区即可")])])}],!1,null,null,null);s.options.__file="鸟哥Linux基础-主机规划和磁盘分区.md";e.default=s.exports}}]);