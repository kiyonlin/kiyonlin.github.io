<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>golang调度器笔记 - Tsing Wind - 清风徐来 水波不兴</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="Kiyon Lin" />
  <meta name="description" content="CPU寄存器 汇编代码所做的工作就是把数据在内存和寄存器中搬来搬去或做一些基础的数学和逻辑运算。 通用寄存器：rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp, r8, r9, r10, r11, r12, r13," />

  <meta name="keywords" content="Hugo, theme, kiyon, kiyonlin" />






<meta name="generator" content="Hugo 0.72.0" />


<link rel="canonical" href="https://kiyonlin.github.io/post/read/golang/golang%E8%B0%83%E5%BA%A6%E5%99%A8%E7%AC%94%E8%AE%B0/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/kiyon.min.fa3d941d1d0e0ddc985804227feabffea55c89883eb0af34e0532a7ae9135151.css" integrity="sha256-&#43;j2UHR0ODdyYWAQif&#43;q//qVciYg&#43;sK804FMqeukTUVE=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="golang调度器笔记" />
<meta property="og:description" content="CPU寄存器 汇编代码所做的工作就是把数据在内存和寄存器中搬来搬去或做一些基础的数学和逻辑运算。 通用寄存器：rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp, r8, r9, r10, r11, r12, r13," />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://kiyonlin.github.io/post/read/golang/golang%E8%B0%83%E5%BA%A6%E5%99%A8%E7%AC%94%E8%AE%B0/" />
<meta property="article:published_time" content="2020-11-27T08:25:05+08:00" />
<meta property="article:modified_time" content="2020-12-04T14:30:05+08:00" />
<meta itemprop="name" content="golang调度器笔记">
<meta itemprop="description" content="CPU寄存器 汇编代码所做的工作就是把数据在内存和寄存器中搬来搬去或做一些基础的数学和逻辑运算。 通用寄存器：rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp, r8, r9, r10, r11, r12, r13,">
<meta itemprop="datePublished" content="2020-11-27T08:25:05&#43;08:00" />
<meta itemprop="dateModified" content="2020-12-04T14:30:05&#43;08:00" />
<meta itemprop="wordCount" content="23614">



<meta itemprop="keywords" content="golang,scheduler,runtime," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="golang调度器笔记"/>
<meta name="twitter:description" content="CPU寄存器 汇编代码所做的工作就是把数据在内存和寄存器中搬来搬去或做一些基础的数学和逻辑运算。 通用寄存器：rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp, r8, r9, r10, r11, r12, r13,"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Tsing Wind</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://kiyonlin.github.io/post/">归档</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://kiyonlin.github.io/tags/">标签</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://kiyonlin.github.io/categories/">分类</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://github.com/kiyonlin" rel="noopener" target="_blank">
              Github
              
              <i class="iconfont">
                <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6C496.064 467.648 528.64 500.224 528.64 500.224 534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92 0 0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"></path>
  <path d="M841.152 457.152c-30.528 0-54.784 24.512-54.784 54.656l0 274.752L237.696 786.56 237.696 237.696l206.016 0c6.656 0 10.752 0 13.248 0C487.68 237.696 512 213.184 512 182.848 512 152.32 487.36 128 456.96 128L183.04 128C153.216 128 128 152.576 128 182.848c0 3.136 0.256 6.272 0.768 9.28C128.256 195.136 128 198.272 128 201.408l0 639.488c0 0.064 0 0.192 0 0.256 0 0.128 0 0.192 0 0.32 0 30.528 24.512 54.784 54.784 54.784l646.976 0c6.592 0 9.728 0 11.712 0 28.736 0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344l0-20.352L896 561.408 896 512.128C896 481.792 871.424 457.152 841.152 457.152z"></path>
</svg>

              </i>
            </a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      Tsing Wind
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://kiyonlin.github.io/post/">归档</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://kiyonlin.github.io/tags/">标签</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://kiyonlin.github.io/categories/">分类</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://github.com/kiyonlin" rel="noopener" target="_blank">
              Github
              
              <i class="iconfont">
                <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M623.36 272.96 473.216 423.04C467.2 429.056 467.072 438.656 472.896 444.416c0 0-6.72-6.656 1.6 1.6C496.064 467.648 528.64 500.224 528.64 500.224 534.464 506.048 544 505.856 550.016 499.904l150.08-150.144 67.328 66.432c9.024 8.96 27.456 4.544 30.4-8.96 19.968-92.608 46.656-227.52 46.656-227.52 6.848-34.496-16.192-56.704-49.92-49.92 0 0-134.656 26.816-227.328 46.784C560.32 178.048 556.352 182.272 554.752 187.136c-3.2 6.208-3.008 14.208 3.776 20.992L623.36 272.96z"></path>
  <path d="M841.152 457.152c-30.528 0-54.784 24.512-54.784 54.656l0 274.752L237.696 786.56 237.696 237.696l206.016 0c6.656 0 10.752 0 13.248 0C487.68 237.696 512 213.184 512 182.848 512 152.32 487.36 128 456.96 128L183.04 128C153.216 128 128 152.576 128 182.848c0 3.136 0.256 6.272 0.768 9.28C128.256 195.136 128 198.272 128 201.408l0 639.488c0 0.064 0 0.192 0 0.256 0 0.128 0 0.192 0 0.32 0 30.528 24.512 54.784 54.784 54.784l646.976 0c6.592 0 9.728 0 11.712 0 28.736 0 52.928-22.976 54.464-51.968C896 843.264 896 842.304 896 841.344l0-20.352L896 561.408 896 512.128C896 481.792 871.424 457.152 841.152 457.152z"></path>
</svg>

              </i>
            </a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">golang调度器笔记</h1>
      
      <div class="post-meta">
        <time datetime="2020-11-27" class="post-time">
          2020-11-27
        </time>
        <div class="post-category">
            <a href="https://kiyonlin.github.io/categories/golang/"> golang </a>
            
          </div>
        <span class="more-meta"> 约 23614 字 </span>
          <span class="more-meta"> 预计阅读 48 分钟 </span>

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#常用指令详解">常用指令详解</a>
      <ul>
        <li><a href="#mov指令"><strong>mov指令</strong></a></li>
        <li><a href="#addsub">add/sub</a></li>
        <li><a href="#callret指令">call/ret指令</a></li>
        <li><a href="#jmpjejlejgjge等等j开头的指令">jmp/je/jle/jg/jge等等j开头的指令</a></li>
        <li><a href="#pushpop">push/pop</a></li>
        <li><a href="#leave指令">leave指令</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#寄存器">寄存器</a>
      <ul>
        <li><a href="#fp虚拟寄存器">FP虚拟寄存器</a></li>
        <li><a href="#sb虚拟寄存器">SB虚拟寄存器</a></li>
        <li><a href="#操作数宽度即操作数的位数">操作数宽度（即操作数的位数）</a></li>
        <li><a href="#函数定义">函数定义</a></li>
      </ul>
    </li>
    <li><a href="#线程本地存储">线程本地存储</a></li>
  </ul>

  <ul>
    <li><a href="#goroutine简介">goroutine简介</a></li>
    <li><a href="#线程模型与调度器">线程模型与调度器</a></li>
    <li><a href="#重要的结构体">重要的结构体</a>
      <ul>
        <li><a href="#stack结构体">stack结构体</a></li>
        <li><a href="#gobuf结构体">gobuf结构体</a></li>
        <li><a href="#g结构体">g结构体</a></li>
        <li><a href="#m结构体">m结构体</a></li>
        <li><a href="#p结构体">p结构体</a></li>
        <li><a href="#schedt结构体">schedt结构体</a></li>
        <li><a href="#重要的全局变量">重要的全局变量</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li><a href="#初始化g0">初始化g0</a></li>
    <li><a href="#主线程与m0绑定">主线程与m0绑定</a></li>
    <li><a href="#初始化m0">初始化m0</a></li>
    <li><a href="#初始化allp">初始化allp</a></li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h1 id="cpu寄存器">CPU寄存器</h1>
<p>汇编代码所做的工作就是把数据在内存和寄存器中搬来搬去或做一些基础的数学和逻辑运算。</p>
<ol>
<li><strong>通用寄存器</strong>：rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp, r8, r9, r10, r11, r12, r13, r14, r15寄存器。CPU对这16个通用寄存器的用途没有做特殊规定，程序员和编译器可以自定义其用途。<strong>rsp 栈顶寄存器和rbp栈基址寄存器</strong>:这两个寄存器都跟函数调用栈有关，其中rsp寄存器一般用来存放函数调用栈的栈顶地址，而rbp寄存器通常用来存放函数的栈帧起始地址，编译器一般使用这两个寄存器加一定偏移的方式来访问函数局部变量或函数参数。</li>
<li><strong>程序计数寄存器（PC寄存器，有时也叫IP寄存器）</strong>：rip寄存器。它用来存放<strong>下一条</strong>即将执行的指令的地址，这个寄存器决定了程序的执行流程；</li>
<li><strong>段寄存器</strong>：fs和gs寄存器。一般用它来实现线程本地存储（TLS），比如AMD64 linux平台下go语言和pthread都使用fs寄存器来实现系统线程的TLS，在本章线程本地存储一节和第二章详细分析goroutine调度器的时候我们可以分别看到Linux平台下Pthread线程库和go是如何使用fs寄存器的。</li>
</ol>
<h1 id="内存">内存</h1>
<ol>
<li>内存中的每个字节都有一个地址</li>
<li>任何大于一个字节的变量在内存中都存储在相邻连续的的几个内存单元之中；</li>
<li>大端存储模式指数据的高字节保存在内存的低地址中，低字节保存在内存的高地址中；小端存储模式指数据的高字节保存在内存的高地址中，低字节保存在内存的低地址中。</li>
</ol>
<h1 id="函数调用栈">函数调用栈</h1>
<p>进程在内存中的布局主要分为4个区域：代码区，数据区，堆和栈。在详细讨论栈之前，先来简单介绍一下其它区域。</p>
<ul>
<li><strong>代码区</strong>，包括能被CPU执行的机器代码（指令）和只读数据比如字符串常量，程序一旦加载完成代码区的大小就不会再变化了。</li>
<li><strong>数据区</strong>，包括程序的全局变量和静态变量（c语言有静态变量，而go没有），与代码区一样，程序加载完毕后数据区的大小也不会发生改变。</li>
<li><strong>堆</strong>，程序运行时动态分配的内存都位于堆中，这部分内存由内存分配器负责管理。<strong>该区域的大小会随着程序的运行而变化</strong>，即当我们向堆请求分配内存但分配器发现堆中的内存不足时，它会向操作系统内核申请向高地址方向扩展堆的大小，而当我们释放内存把它归还给堆时如果内存分配器发现剩余空闲内存太多则又会向操作系统请求向低地址方向收缩堆的大小。从这个内存申请和释放流程可以看出，我们从堆上分配的内存用完之后必须归还给堆，否则内存分配器可能会反复向操作系统申请扩展堆的大小从而导致堆内存越用越多，最后出现内存不足，这就是所谓的内存泄漏。值的一提的是传统的c/c++代码就必须小心处理内存的分配和释放，而在go语言中，有垃圾回收器帮助我们，所以程序员只管申请内存，而不用管内存的释放，这大大降低了程序员的心智负担，这不光是提高了程序员的生产力，更重要的是还会减少很多bug的产生。</li>
</ul>
<p><strong>函数调用栈</strong></p>
<p>函数调用栈简称栈，在程序运行过程中，不管是函数的执行还是函数调用，栈都起着非常重要的作用，它主要被用来：</p>
<ul>
<li>保存函数的局部变量；</li>
<li>向被调用函数传递参数；</li>
<li>返回函数的返回值；</li>
<li>保存函数的返回地址。返回地址是指从被调用函数返回后调用者应该继续执行的指令地址，在汇编指令一节介绍call指令时我们将会对返回地址做更加详细的说明。</li>
</ul>
<p>每个函数在执行过程中都需要使用一块栈内存用来保存上述这些值，我们称这块栈内存为某函数的栈帧(stack frame)。</p>
<p><strong>寄存器rbp和rsp始终指向正在执行的函数的栈帧</strong>。</p>
<ul>
<li>rbp，一般用来指向函数栈帧的起始位置</li>
<li>rsp，始终指向函数调用栈栈顶</li>
</ul>
<p>说明</p>
<ul>
<li>调用函数时，参数和返回值都是存放在调用者的栈帧之中，而不是在被调函数之中；</li>
<li>假如目前正在执行C函数，且函数调用链为A()-&gt;B()-&gt;C()，所以以栈帧为单位来看的话，C函数的栈帧目前位于栈顶；</li>
<li>CPU硬件寄存器rsp指向整个栈的栈顶，当然它也指向C函数的栈帧的栈顶，而rbp寄存器指向的是C函数栈帧的起始位置；</li>
<li>每个函数的栈帧大小可能都不同，因为不同的函数局部变量的个数以及所占内存的大小都不尽相同；</li>
<li>有些编译器比如gcc会把参数和返回值放在寄存器中而不是栈中，go语言中函数的参数和返回值都是放在栈上的；</li>
</ul>
<h1 id="汇编指令">汇编指令</h1>
<p>里先对AT&amp;T格式的汇编指令格式做一个简要的说明：</p>
<ol>
<li>AT&amp;T格式的汇编指令中，寄存器名需要加%作为前缀；</li>
<li>有2个操作数的指令中，第一个操作数是源操作数，第二个是目的操作数。例如 mov   %eax,%esi，这条指令表示把eax寄存器中的值拷贝给esi；</li>
<li>立即操作数需要加上$符号做前缀，如  &ldquo;mov $0x1 %rdi&rdquo; 这条指令中第一个操作数不是寄存器，也不是内存地址，而是直接写在指令中的一个常数，这种操作数叫做<strong>立即操作数</strong>。这条指令表示把数值0x1放入rdi寄存器中。</li>
<li><strong>寄存器间接寻址的格式为  offset(%register)</strong>，如果offset为0，则可以略去偏移不写直接写成(%register)。何为间接寻址呢？其实就是指指令中的寄存器并不是真正的源操作数或目的操作数，寄存器的值是一个内存地址，这个地址对应的内存才是真正的源或目的操作数，比如 mov   %rax, (%rsp)这条指令，第二个操作数(%rsp)中的寄存器的名字用括号括起来了，表示间接寻址，rsp的值是一个内存地址，这条指令的真实意图是把rax寄存器中的值赋值给rsp寄存器的值（内存地址）对应的内存，rsp寄存器本身的值不会被修改，作为比较，我们看一下 mov   %rax, %rsp 这条指令 ，这里第二个操作数仅仅少了个括号，变成了直接寻址，意思完全不一样了，这条指令的意思是把rax的值赋给rsp，这样rsp寄存器的值被修改为跟rax寄存器一样的值了。offset表示偏移，如-0x8(%rbp)，-0x8就是偏移量，整个表示rbp寄存器里面保存的地址值先减去8（因为偏移是负8）得到的地址对应的内存。</li>
<li>与内存相关的一些指令的操作码会加上b, w, l和q字母分别表示操作的内存是1，2，4还是8个字节，比如指令 movl  $0x0,-0x8(%rbp) ，这条指令操作码movl的后缀字母l说明我们要把从-0x8(%rbp) 这个地址开始的4个内存单元赋值为0。</li>
</ol>
<h2 id="常用指令详解">常用指令详解</h2>
<h3 id="mov指令"><strong>mov指令</strong></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">mov src dst
mov %rsp,%rbp       # 直接寻址，把rsp的值拷贝给rbp，相当于 rbp = rsp
mov -0x8(%rbp),%edx # 源操作数间接寻址，目的操作数直接寻址。从内存中读取4个字节到edx寄存器
mov %rsi,-0x8(%rbp) # 源操作数直接寻址，目的操作数间接寻址。把rsi寄存器中的8字节值写入内存
</code></pre></td></tr></table>
</div>
</div><h3 id="addsub">add/sub</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">add src dst
sub src dst
sub $0x350,%rsp  # 源操作数是立即操作数，目的操作数直接寻址。rsp = rsp - 0x350
add %rdx,%rax    # 直接寻址。rax = rax + rdx
addl $0x1,-0x8(%rbp) # 源操作数是立即操作数，目的操作数间接寻址。内存中的值加1（addl后缀字母l表示操作内存中的4个字节）
</code></pre></td></tr></table>
</div>
</div><h3 id="callret指令">call/ret指令</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">call src
ret
</code></pre></td></tr></table>
</div>
</div><p>call指令执行函数调用。CPU执行call指令时首先会把rip寄存器中的值入栈，然后设置rip值为目标地址，又因为<strong>rip寄存器决定了下一条需要执行的指令</strong>，所以当CPU执行完当前call指令后就会跳转到目标地址去执行。</p>
<p>ret指令从被调用函数返回调用函数，它的实现原理是把call指令入栈的返回地址弹出给rip寄存器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">#调用函数片段
0x0000000000400559 : callq 0x400526 &lt;sum&gt;
0x000000000040055e : mov   %eax,-0x4(%rbp)

#被调用函数片段
0x0000000000400526 : push   %rbp
......
0x000000000040053f : retq  
</code></pre></td></tr></table>
</div>
</div><p>上面代码片段中，调用函数使用callq  0x400526指令调用0x400526处的函数，0x400526是被调用函数的第一条指令所在的地址。被调用函数在0x40053f处执行retq指令返回调用函数继续执行0x40055e地址处的指令。注意这两条指令会涉及入栈和出栈操作，所以会影响rsp寄存器的值。</p>
<h3 id="jmpjejlejgjge等等j开头的指令">jmp/je/jle/jg/jge等等j开头的指令</h3>
<p>这些都属于跳转指令，操作码后面直接跟要跳转到的地址或存有地址的寄存器，这些指令与高级编程语言中的 goto 和 if 等语句对应。用法示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">jmp    0x4005f2
jle    0x4005ee
jl     0x4005b8
</code></pre></td></tr></table>
</div>
</div><h3 id="pushpop">push/pop</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">push src
pop dst
</code></pre></td></tr></table>
</div>
</div><p>专用于函数调用栈的入栈出栈指令，<strong>这两个指令都会自动修改rsp寄存器</strong>。</p>
<p>push入栈时rsp寄存器的值先减去8把栈位置留出来，然后把操作数复制到rsp所指位置。push指令相当于：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">sub $8,%rsp
mov dst,(%rsp)
</code></pre></td></tr></table>
</div>
</div><p>pop出栈时先把rsp寄存器所指位置的数据复制到目的操作数中，然后rsp寄存器的值加8。pop指令相当于：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">mov (%rsp),dst
add $8,%rsp
</code></pre></td></tr></table>
</div>
</div><h3 id="leave指令">leave指令</h3>
<p>leave指令没有操作数，它一般放在函数的尾部ret指令之前，用于调整rsp和rbp，这条指令相当于如下两条指令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">mov %rbp,%rsp
pop %rbp
</code></pre></td></tr></table>
</div>
</div><h1 id="go汇编语言">go汇编语言</h1>
<h2 id="寄存器">寄存器</h2>
<table>
<thead>
<tr>
<th>AMD64</th>
<th>rax</th>
<th>rbx</th>
<th>rcx</th>
<th>rdx</th>
<th>rsi</th>
<th>rdi</th>
<th>rbp</th>
<th>rsp</th>
<th>r8~r15</th>
<th>rip</th>
</tr>
</thead>
<tbody>
<tr>
<td>GO汇编</td>
<td>AX</td>
<td>BX</td>
<td>CX</td>
<td>DX</td>
<td>SI</td>
<td>DI</td>
<td>BP</td>
<td>SP</td>
<td>R8~R15</td>
<td>PC</td>
</tr>
</tbody>
</table>
<h3 id="fp虚拟寄存器">FP虚拟寄存器</h3>
<p>主要用来引用函数参数。go语言规定函数调用时参数都必须放在栈上，比如被调用函数使用 first_arg+0(FP)  来引用调用者传递进来的第一个参数，用second_arg+8(FP)来引用第二个参数 ，以此类推，这里的first_arg和second_arg仅仅是一个帮助我们阅读源代码的符号，对编译器来说无实际意义，+0和+8表示相对于FP寄存器的偏移量。</p>
<h3 id="sb虚拟寄存器">SB虚拟寄存器</h3>
<p>保存程序地址空间的起始地址。还记得在函数调用栈一节我们看过的进程在内存中的布局那张图吗，这个SB寄存器保存的值就是代码区的起始地址，它主要用来定位全局符号。go汇编中的函数定义、函数调用、全局变量定义以及对其引用会用到这个SB虚拟寄存器。对于这个虚拟寄存器，我们不用过多的关注，在代码中看到它时知道它是一个虚拟寄存器就行了。</p>
<h3 id="操作数宽度即操作数的位数">操作数宽度（即操作数的位数）</h3>
<p>go汇编中，寄存器的名字没有位数之分，比如AX寄存器没有什么RAX, EAX之类的名字，指令中一律只能使用AX。所以如果指令中有操作数寄存器或是指令需要访问内存，则操作码都需要带上后缀B(8位)、W(16位)、D(32位)或Q(64位)。</p>
<h3 id="函数定义">函数定义</h3>
<p>以go runtime中的gogo函数为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">// func gogo(buf *gobuf)
// restore state from Gobuf; longjmp
TEXT runtime·gogo(SB), NOSPLIT, $16-8
// ......
</code></pre></td></tr></table>
</div>
</div><ul>
<li>TEXT runtime·gogo(SB)：指明在代码区定义了一个名字叫gogo的全局函数（符号），该函数属于runtime包。</li>
<li>NOSPLIT：指示编译器不要在这个函数中插入检查栈是否溢出的代码。</li>
<li>$16-8：数字16说明此函数的栈帧大小为16字节，8说明此函数的参数和返回值一共需要占用8字节内存。因为这里的gogo函数没有返回值，只有一个指针参数，对于AMD64平台来说指针就是8字节。go语言中函数调用的参数和函数返回值都是放在栈上的，而且这部分栈内存是由调用者而非被调用函数负责预留，所以在函数定义时需要说明到底需要在调用者的栈帧中预留多少空间。</li>
</ul>
<h2 id="线程本地存储">线程本地存储</h2>
<p><strong>线程本地存储又叫线程局部存储，其英文为Thread Local Storage，简称TLS</strong>，是线程私有的全局变量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;asm/prctl.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;sys/prctl.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">__thread</span> <span class="kt">int</span> <span class="n">g</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 1，这里增加了__thread关键字，把g定义成私有的全局变量，每个线程都有一个g变量
</span><span class="c1"></span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">start</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;start, g[%p] : %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="p">);</span> <span class="c1">// 4，打印本线程私有全局变量g的地址和值
</span><span class="c1"></span>
		<span class="n">g</span><span class="o">++</span><span class="p">;</span> <span class="c1">// 5，修改本线程私有全局变量g的值
</span><span class="c1"></span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
		<span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>

		<span class="n">g</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>  <span class="c1">// 2，主线程给私有全局变量赋值为100
</span><span class="c1"></span>
		<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">// 3，创建子线程执行start()函数
</span><span class="c1"></span>		<span class="n">pthread_join</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// 6，等待子线程运行结束
</span><span class="c1"></span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;main, g[%p] : %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">g</span><span class="p">,</span> <span class="n">g</span><span class="p">);</span> <span class="c1">// 7，打印主线程的私有全局变量g的地址和值
</span><span class="c1"></span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>gcc编译器（其实还有线程库以及内核的支持）使用了CPU的fs段寄存器来实现线程本地存储</strong>，不同的线程中fs段基地址是不一样的，这样看似同一个全局变量但在不同线程中却拥有不同的内存地址，实现了线程私有的全局变量。</p>
<h1 id="goroutine调度器概述">goroutine调度器概述</h1>
<h2 id="goroutine简介">goroutine简介</h2>
<p>goroutine是Go语言实现的用户态线程，主要用来解决操作系统线程太“重”的问题，所谓的太重，主要表现在以下两个方面：</p>
<ol>
<li><strong>创建和切换太重</strong>：操作系统线程的创建和切换都需要进入内核，而进入内核所消耗的性能代价比较高，开销较大；</li>
<li><strong>内存使用太重</strong>：一方面，为了尽量避免极端情况下操作系统线程栈的溢出，内核在创建操作系统线程时默认会为其分配一个较大的栈内存（虚拟地址空间，内核并不会一开始就分配这么多的物理内存），然而在绝大多数情况下，系统线程远远用不了这么多内存，这导致了浪费；另一方面，栈内存空间一旦创建和初始化完成之后其大小就不能再有变化，这决定了在某些特殊场景下系统线程栈还是有溢出的风险。</li>
</ol>
<p>用户态的goroutine则轻量得多：</p>
<ol>
<li>goroutine是用户态线程，其创建和切换都在用户代码中完成而无需进入操作系统内核，所以其开销要远远小于系统线程的创建和切换；</li>
<li>goroutine启动时默认栈大小只有2k，这在多数情况下已经够用了，即使不够用，goroutine的栈也会自动扩大，同时，如果栈太大了过于浪费它还能自动收缩，这样既没有栈溢出的风险，也不会造成栈内存空间的大量浪费。</li>
</ol>
<h2 id="线程模型与调度器">线程模型与调度器</h2>
<p><strong>对goroutine的调度，是指程序代码按照一定的算法在适当的时候挑选出合适的goroutine并放到CPU上去运行的过程</strong>，这些负责对goroutine进行调度的程序代码我们称之为<strong>goroutine调度器</strong>。用极度简化了的伪代码来描述goroutine调度器的工作流程大概是下面这个样子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 程序启动时的初始化代码
</span><span class="c1"></span><span class="o">......</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">N</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span> <span class="c1">// 创建N个操作系统线程执行schedule函数
</span><span class="c1"></span>    <span class="nf">create_os_thread</span><span class="p">(</span><span class="nx">schedule</span><span class="p">)</span> <span class="c1">// 创建一个操作系统线程执行schedule函数
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 定义一个线程私有全局变量，注意它是一个指向m结构体对象的指针
</span><span class="c1">// ThreadLocal用来定义线程私有全局变量
</span><span class="c1"></span><span class="nx">ThreadLocal</span> <span class="nx">self</span> <span class="o">*</span><span class="nx">m</span>
<span class="c1">//schedule函数实现调度逻辑
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">schedule</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 创建和初始化m结构体对象，并赋值给私有全局变量self
</span><span class="c1"></span>    <span class="nx">self</span> <span class="p">=</span> <span class="nf">initm</span><span class="p">()</span>  
    <span class="k">for</span> <span class="p">{</span> <span class="c1">//调度循环
</span><span class="c1"></span>          <span class="k">if</span> <span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nx">runqueue</span> <span class="nx">is</span> <span class="nx">empty</span><span class="p">)</span> <span class="p">{</span>
                 <span class="c1">// 根据某种算法从全局运行队列中找出一个需要运行的goroutine
</span><span class="c1"></span>                 <span class="nx">g</span> <span class="o">:=</span> <span class="nf">find_a_runnable_goroutine_from_global_runqueue</span><span class="p">()</span>
           <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                 <span class="c1">// 根据某种算法从私有的局部运行队列中找出一个需要运行的goroutine
</span><span class="c1"></span>                 <span class="nx">g</span> <span class="o">:=</span> <span class="nf">find_a_runnable_goroutine_from_local_runqueue</span><span class="p">()</span>
           <span class="p">}</span>
          <span class="nf">run_g</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span> <span class="c1">// CPU运行该goroutine，直到需要调度其它goroutine才返回
</span><span class="c1"></span>          <span class="nf">save_status_of_g</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span> <span class="c1">// 保存goroutine的状态，主要是寄存器的值
</span><span class="c1"></span>     <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>关系示意图</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐  
  schedt grq                               
│                                       │  
                                           
│      .─.     .─.     .─.     .─.      │  
  ────( G )───( G )───( G )───( G )────    
│      `─&#39;     `─&#39;     `─&#39;     `─&#39;      │  
                                           
└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘  
                                           
    .─.             .─.             .─.    
   ( G )           ( G )           ( G )   
    `┬&#39;             `┬&#39;             `┬&#39;    
     │               │               │     
     Λ               Λ               Λ     
    ╱ ╲             ╱ ╲             ╱ ╲    
   ▕ m ▏           ▕ m ▏           ▕ m ▏   
    ╲ ╱             ╲ ╱             ╲ ╱    
     V               V               V     
     │               │               │     
   ┌─┴─┐           ┌─┴─┐           ┌─┴─┐   
   │ p │           │ p │           │ p │   
   └─┬─┘           └─┬─┘           └─┬─┘   
┌ ─ ─│─ ─ ┐     ┌ ─ ─│─ ─ ┐     ┌ ─ ─│─ ─ ┐
 lrq │           lrq │           lrq │     
│   .┴.   │     │   .┴.   │     │   .┴.   │
   ( G )           ( G )           ( G )   
│   `┬&#39;   │     │   `┬&#39;   │     │   `┬&#39;   │
    .┴.             .┴.             .┴.    
│  ( G )  │     │  ( G )  │     │  ( G )  │
    `┬&#39;             `┬&#39;             `┬&#39;    
│   .┴.   │     │   .┴.   │     │   .┴.   │
   ( G )           ( G )           ( G )   
│   `┬&#39;   │     │   `┬&#39;   │     │   `┬&#39;   │
     │               │               │     
└ ─ ─ ─ ─ ┘     └ ─ ─ ─ ─ ┘     └ ─ ─ ─ ─ ┘
</code></pre></td></tr></table>
</div>
</div><h2 id="重要的结构体">重要的结构体</h2>
<p>结构体的定义全部位于Go语言的源代码路径下的<code>runtime/runtime2.go</code>文件之中。</p>
<h3 id="stack结构体">stack结构体</h3>
<p>stack结构体主要用来记录goroutine所使用的栈的信息，包括栈顶和栈底位置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Stack describes a Go execution stack.
</span><span class="c1">// The bounds of the stack are exactly [lo, hi),
</span><span class="c1">// with no implicit data structures on either side.
</span><span class="c1">//用于记录goroutine使用的栈的起始和结束位置
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">stack</span> <span class="kd">struct</span> <span class="p">{</span>  
    <span class="nx">lo</span> <span class="kt">uintptr</span>    <span class="c1">// 栈顶，指向内存低地址
</span><span class="c1"></span>    <span class="nx">hi</span> <span class="kt">uintptr</span>    <span class="c1">// 栈底，指向内存高地址
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="gobuf结构体">gobuf结构体</h3>
<p>gobuf结构体用于保存goroutine的调度信息，主要包括CPU的几个寄存器的值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">gobuf</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// The offsets of sp, pc, and g are known to (hard-coded in) libmach.
</span><span class="c1"></span>    <span class="c1">//
</span><span class="c1"></span>    <span class="c1">// ctxt is unusual with respect to GC: it may be a
</span><span class="c1"></span>    <span class="c1">// heap-allocated funcval, so GC needs to track it, but it
</span><span class="c1"></span>    <span class="c1">// needs to be set and cleared from assembly, where it&#39;s
</span><span class="c1"></span>    <span class="c1">// difficult to have write barriers. However, ctxt is really a
</span><span class="c1"></span>    <span class="c1">// saved, live register, and we only ever exchange it between
</span><span class="c1"></span>    <span class="c1">// the real register and the gobuf. Hence, we treat it as a
</span><span class="c1"></span>    <span class="c1">// root during stack scanning, which means assembly that saves
</span><span class="c1"></span>    <span class="c1">// and restores it doesn&#39;t need write barriers. It&#39;s still
</span><span class="c1"></span>    <span class="c1">// typed as a pointer so that any other writes from Go get
</span><span class="c1"></span>    <span class="c1">// write barriers.
</span><span class="c1"></span>    <span class="nx">sp</span>   <span class="kt">uintptr</span>  <span class="c1">// 保存CPU的rsp寄存器的值
</span><span class="c1"></span>    <span class="nx">pc</span>   <span class="kt">uintptr</span>  <span class="c1">// 保存CPU的rip寄存器的值
</span><span class="c1"></span>    <span class="nx">g</span>    <span class="nx">guintptr</span> <span class="c1">// 记录当前这个gobuf对象属于哪个goroutine
</span><span class="c1"></span>    <span class="nx">ctxt</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
 
    <span class="c1">// 保存系统调用的返回值，因为从系统调用返回之后如果p被其它工作线程抢占，
</span><span class="c1"></span>    <span class="c1">// 则这个goroutine会被放入全局运行队列被其它工作线程调度，其它线程需要知道系统调用的返回值。
</span><span class="c1"></span>    <span class="nx">ret</span>  <span class="nx">sys</span><span class="p">.</span><span class="nx">Uintreg</span>  
    <span class="nx">lr</span>   <span class="kt">uintptr</span>
 
    <span class="c1">// 保存CPU的rbp寄存器的值
</span><span class="c1"></span>    <span class="nx">bp</span>   <span class="kt">uintptr</span> <span class="c1">// for GOEXPERIMENT=framepointer
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="g结构体">g结构体</h3>
<p>g结构体用于代表一个goroutine，该结构体保存了goroutine的所有信息，包括栈，gobuf结构体和其它的一些状态信息。调度器代码可以通过g对象来对goroutine进行调度，当goroutine被调离CPU时，调度器代码负责把CPU寄存器的值保存在g对象的成员变量之中，当goroutine被调度起来运行时，调度器代码又负责把g对象的成员变量所保存的寄存器的值恢复到CPU的寄存器。：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 前文所说的g结构体，它代表了一个goroutine
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// Stack parameters.
</span><span class="c1"></span>    <span class="c1">// stack describes the actual stack memory: [stack.lo, stack.hi).
</span><span class="c1"></span>    <span class="c1">// stackguard0 is the stack pointer compared in the Go stack growth prologue.
</span><span class="c1"></span>    <span class="c1">// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
</span><span class="c1"></span>    <span class="c1">// stackguard1 is the stack pointer compared in the C stack growth prologue.
</span><span class="c1"></span>    <span class="c1">// It is stack.lo+StackGuard on g0 and gsignal stacks.
</span><span class="c1"></span>    <span class="c1">// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
</span><span class="c1"></span> 
    <span class="c1">// 记录该goroutine使用的栈
</span><span class="c1"></span>    <span class="nx">stack</span>       <span class="nx">stack</span>   <span class="c1">// offset known to runtime/cgo
</span><span class="c1"></span>    <span class="c1">// 下面两个成员用于栈溢出检查，实现栈的自动伸缩，抢占调度也会用到stackguard0
</span><span class="c1"></span>    <span class="nx">stackguard0</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span><span class="c1"></span>    <span class="nx">stackguard1</span> <span class="kt">uintptr</span> <span class="c1">// offset known to liblink
</span><span class="c1"></span>
    <span class="o">......</span>
 
    <span class="c1">// 此goroutine正在被哪个工作线程执行
</span><span class="c1"></span>    <span class="nx">m</span>              <span class="o">*</span><span class="nx">m</span>      <span class="c1">// current m; offset known to arm liblink
</span><span class="c1"></span>    <span class="c1">// 保存调度信息，主要是几个寄存器的值
</span><span class="c1"></span>    <span class="nx">sched</span>          <span class="nx">gobuf</span>
 
    <span class="o">......</span>
    <span class="c1">// schedlink字段指向全局运行队列中的下一个g，
</span><span class="c1"></span>    <span class="c1">//所有位于全局运行队列中的g形成一个链表
</span><span class="c1"></span>    <span class="nx">schedlink</span>      <span class="nx">guintptr</span>

    <span class="o">......</span>
    <span class="c1">// 抢占调度标志，如果需要抢占调度，设置preempt为true
</span><span class="c1"></span>    <span class="nx">preempt</span>        <span class="kt">bool</span>       <span class="c1">// preemption signal, duplicates stackguard0 = stackpreempt
</span><span class="c1"></span>
   <span class="o">......</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="m结构体">m结构体</h3>
<p>m结构体用来代表工作线程，它保存了m自身使用的栈信息，当前正在运行的goroutine以及与m绑定的p等信息，详见下面定义中的注释。：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// g0主要用来记录工作线程使用的栈信息，在执行调度代码时需要使用这个栈
</span><span class="c1"></span>    <span class="c1">// 执行用户goroutine代码时，使用用户goroutine自己的栈，调度时会发生栈的切换
</span><span class="c1"></span>    <span class="nx">g0</span>      <span class="o">*</span><span class="nx">g</span>     <span class="c1">// goroutine with scheduling stack
</span><span class="c1"></span>
    <span class="c1">// 通过TLS实现m结构体对象与工作线程之间的绑定
</span><span class="c1"></span>    <span class="nx">tls</span>           <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">uintptr</span>   <span class="c1">// thread-local storage (for x86 extern register)
</span><span class="c1"></span>    <span class="nx">mstartfn</span>      <span class="kd">func</span><span class="p">()</span>
    <span class="c1">// 指向工作线程正在运行的goroutine的g结构体对象
</span><span class="c1"></span>    <span class="nx">curg</span>          <span class="o">*</span><span class="nx">g</span>       <span class="c1">// current running goroutine
</span><span class="c1"></span> 
    <span class="c1">// 记录与当前工作线程绑定的p结构体对象
</span><span class="c1"></span>    <span class="nx">p</span>             <span class="nx">puintptr</span> <span class="c1">// attached p for executing go code (nil if not executing go code)
</span><span class="c1"></span>    <span class="nx">nextp</span>         <span class="nx">puintptr</span>
    <span class="nx">oldp</span>          <span class="nx">puintptr</span> <span class="c1">// the p that was attached before executing a syscall
</span><span class="c1"></span>   
    <span class="c1">// spinning状态：表示当前工作线程正在试图从其它工作线程的本地运行队列偷取goroutine
</span><span class="c1"></span>    <span class="nx">spinning</span>      <span class="kt">bool</span> <span class="c1">// m is out of work and is actively looking for work
</span><span class="c1"></span>    <span class="nx">blocked</span>       <span class="kt">bool</span> <span class="c1">// m is blocked on a note
</span><span class="c1"></span>   
    <span class="c1">// 没有goroutine需要运行时，工作线程睡眠在这个park成员上，
</span><span class="c1"></span>    <span class="c1">// 其它线程通过这个park唤醒该工作线程
</span><span class="c1"></span>    <span class="nx">park</span>          <span class="nx">note</span>
    <span class="c1">// 记录所有工作线程的一个链表
</span><span class="c1"></span>    <span class="nx">alllink</span>       <span class="o">*</span><span class="nx">m</span> <span class="c1">// on allm
</span><span class="c1"></span>    <span class="nx">schedlink</span>     <span class="nx">muintptr</span>

    <span class="c1">// Linux平台thread的值就是操作系统线程ID
</span><span class="c1"></span>    <span class="nx">thread</span>        <span class="kt">uintptr</span> <span class="c1">// thread handle
</span><span class="c1"></span>    <span class="nx">freelink</span>      <span class="o">*</span><span class="nx">m</span>      <span class="c1">// on sched.freem
</span><span class="c1"></span>
    <span class="o">......</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="p结构体">p结构体</h3>
<p>p结构体用于保存工作线程执行go代码时所必需的资源，比如goroutine的运行队列，内存分配用到的缓存等等。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">lock</span> <span class="nx">mutex</span>

    <span class="nx">status</span>       <span class="kt">uint32</span> <span class="c1">// one of pidle/prunning/...
</span><span class="c1"></span>    <span class="nx">link</span>            <span class="nx">puintptr</span>
    <span class="nx">schedtick</span>   <span class="kt">uint32</span>     <span class="c1">// incremented on every scheduler call
</span><span class="c1"></span>    <span class="nx">syscalltick</span>  <span class="kt">uint32</span>     <span class="c1">// incremented on every system call
</span><span class="c1"></span>    <span class="nx">sysmontick</span>  <span class="nx">sysmontick</span> <span class="c1">// last tick observed by sysmon
</span><span class="c1"></span>    <span class="nx">m</span>                <span class="nx">muintptr</span>   <span class="c1">// back-link to associated m (nil if idle)
</span><span class="c1"></span>
    <span class="o">......</span>

    <span class="c1">// Queue of runnable goroutines. Accessed without lock.
</span><span class="c1"></span>    <span class="c1">//本地goroutine运行队列
</span><span class="c1"></span>    <span class="nx">runqhead</span> <span class="kt">uint32</span>  <span class="c1">// 队列头
</span><span class="c1"></span>    <span class="nx">runqtail</span> <span class="kt">uint32</span>     <span class="c1">// 队列尾
</span><span class="c1"></span>    <span class="nx">runq</span>     <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span>  <span class="c1">//使用数组实现的循环队列
</span><span class="c1"></span>    <span class="c1">// runnext, if non-nil, is a runnable G that was ready&#39;d by
</span><span class="c1"></span>    <span class="c1">// the current G and should be run next instead of what&#39;s in
</span><span class="c1"></span>    <span class="c1">// runq if there&#39;s time remaining in the running G&#39;s time
</span><span class="c1"></span>    <span class="c1">// slice. It will inherit the time left in the current time
</span><span class="c1"></span>    <span class="c1">// slice. If a set of goroutines is locked in a
</span><span class="c1"></span>    <span class="c1">// communicate-and-wait pattern, this schedules that set as a
</span><span class="c1"></span>    <span class="c1">// unit and eliminates the (potentially large) scheduling
</span><span class="c1"></span>    <span class="c1">// latency that otherwise arises from adding the ready&#39;d
</span><span class="c1"></span>    <span class="c1">// goroutines to the end of the run queue.
</span><span class="c1"></span>    <span class="nx">runnext</span> <span class="nx">guintptr</span>

    <span class="c1">// Available G&#39;s (status == Gdead)
</span><span class="c1"></span>    <span class="nx">gFree</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">gList</span>
        <span class="nx">n</span> <span class="kt">int32</span>
    <span class="p">}</span>

    <span class="o">......</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="schedt结构体">schedt结构体</h3>
<p>schedt结构体用来保存调度器的状态信息和goroutine的全局运行队列。因为每个Go程序只有一个调度器，所以在每个Go程序中schedt结构体只有一个实例对象，该实例对象在源代码中被定义成了一个共享的全局变量，这样每个工作线程都可以访问它以及它所拥有的goroutine运行队列，我们称这个运行队列为<strong>全局运行队列</strong>。：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">schedt</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// accessed atomically. keep at top to ensure alignment on 32-bit systems.
</span><span class="c1"></span>    <span class="nx">goidgen</span>  <span class="kt">uint64</span>
    <span class="nx">lastpoll</span> <span class="kt">uint64</span>

    <span class="nx">lock</span> <span class="nx">mutex</span>

    <span class="c1">// When increasing nmidle, nmidlelocked, nmsys, or nmfreed, be
</span><span class="c1"></span>    <span class="c1">// sure to call checkdead().
</span><span class="c1"></span>
    <span class="c1">// 由空闲的工作线程组成链表
</span><span class="c1"></span>    <span class="nx">midle</span>        <span class="nx">muintptr</span> <span class="c1">// idle m&#39;s waiting for work
</span><span class="c1"></span>    <span class="c1">// 空闲的工作线程的数量
</span><span class="c1"></span>    <span class="nx">nmidle</span>       <span class="kt">int32</span>    <span class="c1">// number of idle m&#39;s waiting for work
</span><span class="c1"></span>    <span class="nx">nmidlelocked</span> <span class="kt">int32</span>    <span class="c1">// number of locked m&#39;s waiting for work
</span><span class="c1"></span>    <span class="nx">mnext</span>        <span class="kt">int64</span>    <span class="c1">// number of m&#39;s that have been created and next M ID
</span><span class="c1"></span>    <span class="c1">// 最多只能创建maxmcount个工作线程
</span><span class="c1"></span>    <span class="nx">maxmcount</span>    <span class="kt">int32</span>    <span class="c1">// maximum number of m&#39;s allowed (or die)
</span><span class="c1"></span>    <span class="nx">nmsys</span>        <span class="kt">int32</span>    <span class="c1">// number of system m&#39;s not counted for deadlock
</span><span class="c1"></span>    <span class="nx">nmfreed</span>      <span class="kt">int64</span>    <span class="c1">// cumulative number of freed m&#39;s
</span><span class="c1"></span>
    <span class="nx">ngsys</span> <span class="kt">uint32</span> <span class="c1">// number of system goroutines; updated atomically
</span><span class="c1"></span>
    <span class="c1">// 由空闲的p结构体对象组成的链表
</span><span class="c1"></span>    <span class="nx">pidle</span>      <span class="nx">puintptr</span> <span class="c1">// idle p&#39;s
</span><span class="c1"></span>    <span class="c1">// 空闲的p结构体对象的数量
</span><span class="c1"></span>    <span class="nx">npidle</span>     <span class="kt">uint32</span>
    <span class="nx">nmspinning</span> <span class="kt">uint32</span> <span class="c1">// See &#34;Worker thread parking/unparking&#34; comment in proc.go.
</span><span class="c1"></span>
    <span class="c1">// Global runnable queue.
</span><span class="c1"></span>    <span class="c1">// goroutine全局运行队列
</span><span class="c1"></span>    <span class="nx">runq</span>     <span class="nx">gQueue</span>
    <span class="nx">runqsize</span> <span class="kt">int32</span>

    <span class="o">......</span>

    <span class="c1">// Global cache of dead G&#39;s.
</span><span class="c1"></span>    <span class="c1">// gFree是所有已经退出的goroutine对应的g结构体对象组成的链表
</span><span class="c1"></span>    <span class="c1">// 用于缓存g结构体对象，避免每次创建goroutine时都重新分配内存
</span><span class="c1"></span>    <span class="nx">gFree</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">lock</span>          <span class="nx">mutex</span>
        <span class="nx">stack</span>        <span class="nx">gList</span> <span class="c1">// Gs with stacks
</span><span class="c1"></span>        <span class="nx">noStack</span>   <span class="nx">gList</span> <span class="c1">// Gs without stacks
</span><span class="c1"></span>        <span class="nx">n</span>              <span class="kt">int32</span>
    <span class="p">}</span>
 
    <span class="o">......</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="重要的全局变量">重要的全局变量</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">allgs</span>     <span class="p">[]</span><span class="o">*</span><span class="nx">g</span>     <span class="c1">// 保存所有的g
</span><span class="c1"></span><span class="nx">allm</span>       <span class="o">*</span><span class="nx">m</span>    <span class="c1">// 所有的m构成的一个链表，包括下面的m0
</span><span class="c1"></span><span class="nx">allp</span>       <span class="p">[]</span><span class="o">*</span><span class="nx">p</span>    <span class="c1">// 保存所有的p，len(allp) == gomaxprocs
</span><span class="c1"></span>
<span class="nx">ncpu</span>             <span class="kt">int32</span>   <span class="c1">// 系统中cpu核的数量，程序启动时由runtime代码初始化
</span><span class="c1"></span><span class="nx">gomaxprocs</span> <span class="kt">int32</span>   <span class="c1">// p的最大值，默认等于ncpu，但可以通过GOMAXPROCS修改
</span><span class="c1"></span>
<span class="nx">sched</span>      <span class="nx">schedt</span>     <span class="c1">// 调度器结构体对象，记录了调度器的工作状态
</span><span class="c1"></span>
<span class="nx">m0</span>  <span class="nx">m</span>       <span class="c1">// 代表进程的主线程
</span><span class="c1"></span><span class="nx">g0</span>   <span class="nx">g</span>        <span class="c1">// m0的g0，也就是m0.g0 = &amp;g0
</span></code></pre></td></tr></table>
</div>
</div><h1 id="goroutine调度器初始化">goroutine调度器初始化</h1>
<p>以下面这个简单的Hello World程序为例，通过跟踪其从启动到退出这一完整的运行流程来分析Go语言调度器的初始化、goroutine的创建与退出、工作线程的调度循环以及goroutine的切换等重要内容。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello World!&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>任何一个由编译型语言（不管是C，C++，go还是汇编语言）所编写的程序在被操作系统加载起来运行时都会顺序经过如下几个阶段：</p>
<ol>
<li>从磁盘上把可执行程序读入内存；</li>
<li>创建进程和主线程；</li>
<li>为主线程分配栈空间；</li>
<li>把由用户在命令行输入的参数拷贝到主线程的栈；</li>
<li>把主线程放入操作系统的运行队列等待被调度执起来运行。</li>
</ol>
<p>在主线程第一次被调度起来执行第一条指令之前，主线程的函数栈如下图所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">┌────────────────────┐          
│▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
│▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
│▨▨▨▨▨▨▨kernel▨▨▨▨▨▨▨│          
│▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
│▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
├────────────────────┼─────┬─   
│□□□□□□□□□□□□□□□□□□□□│     │    
│□□□□□□□......□□□□□□□│     │main
│□□□□□□□□□□□□□□□□□□□□│    thread
├────────────────────┤     stack
│                    │     │    
│    argv<span class="o">[</span>...<span class="o">]</span>       │     │    
│                    │     │    
├────────────────────┤     │    
│                    │     │    
│       argc         │&lt;-sp │    
│                    │     │    
├────────────────────┤     ▼    
│                    │          
│                    │          
│                    │          
│                    │          
│                    │          
└────────────────────┘          
</code></pre></td></tr></table>
</div>
</div><h2 id="初始化g0">初始化g0</h2>
<p>全局变量g0的主要作用是提供一个栈供runtime代码执行，因此这里主要对g0的几个与栈有关的成员进行了初始化，从这里可以看出g0的栈大约有64K，地址范围为 SP - 64*1024 + 104 ～ SP。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">//runtime/asm_amd64.s : 96

// create istack out of the given (operating system) stack.
// _cgo_init may update stackguard.
//下面这段代码从系统线程的栈空分出一部分当作g0的栈，然后初始化g0的栈信息和stackgard
MOVQ$runtime·g0(SB), DI       //g0的地址放入DI寄存器
LEAQ(-64*1024+104)(SP), BX //BX = SP - 64*1024 + 104
MOVQBX, g_stackguard0(DI) //g0.stackguard0 = SP - 64*1024 + 104
MOVQBX, g_stackguard1(DI) //g0.stackguard1 = SP - 64*1024 + 104
MOVQBX, (g_stack+stack_lo)(DI) //g0.stack.lo = SP - 64*1024 + 104
MOVQSP, (g_stack+stack_hi)(DI) //g0.stack.hi = SP
</code></pre></td></tr></table>
</div>
</div><p>运行完上面这几行指令后g0与栈之间的关系如下图所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">                                       ┌────────────────────┐          
                                       │▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
                                       │▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
                                       │▨▨▨▨▨▨▨kernel▨▨▨▨▨▨▨│          
                                       │▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
                                       │▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
                                       ├────────────────────┼─────┬─   
┌───g0───────────────┐                 │□□□□□□□□□□□□□□□□□□□□│     │    
│                    │                 │□□□□□□□......□□□□□□□│     │main
│                    │                 │□□□□□□□□□□□□□□□□□□□□│    thread
│                    │                 ├────────────────────┤     stack
│       ......       │                 │    argv<span class="o">[</span>...<span class="o">]</span>       │◀─┐  │    
│                    │                 ├────────────────────┤  │  │    
│                    │                 │       argc         │  │  │    
│                    │                 ├────────────────────┤  │  │    
├────────────────────┤                 │       ......       │  │  │    
│    stackguard1     │━━━━━━━━┓        ├────────────────────┤  │  │    
├────────────────────┤        ┃        │       argv         │──┘  │    
│    stackguard0     │━━━━━━━━┫        ├────────────────────┤     ▼    
├────────────────────┤        ┃        │       argc         │          
│     stack.hi       │━━━━┓   ┃        ├────────────────────┤          
├────────────────────┤    ┃   ┃        │                    │          
│     stack.lo       │━━━━╋━━━┫        ├────────────────────┤          
└────────────────────┘    ┃   ┃        │                    │          
                          ┗━━━╋━━━━━━━━▶────────────────────┤&lt;-sp      
                              ┃        │                    │          
                              ┃        │  <span class="m">64</span> * <span class="m">1024</span> - <span class="m">104</span>   │          
                              ┃        │      bytes         │          
                              ┃        │                    │          
                              ┃        │                    │          
                              ┗━━━━━━━━▶────────────────────┘          
</code></pre></td></tr></table>
</div>
</div><h2 id="主线程与m0绑定">主线程与m0绑定</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">runtime/asm_amd64.s : 188

//下面开始初始化tls(thread local storage,线程本地存储)
LEAQruntime·m0+m_tls(SB), DI //DI = &amp;m0.tls，取m0的tls成员的地址到DI寄存器
CALLruntime·settls(SB) //调用settls设置线程本地存储，settls函数的参数在DI寄存器中

// store through it, to make sure it works
//验证settls是否可以正常工作，如果有问题则abort退出程序
get_tls(BX) //获取fs段基地址并放入BX寄存器，其实就是m0.tls[1]的地址，get_tls的代码由编译器生成
MOVQ$0x123, g(BX) //把整型常量0x123拷贝到fs段基地址偏移-8的内存位置，也就是m0.tls[0] = 0x123
MOVQruntime·m0+m_tls(SB), AX //AX = m0.tls[0]
CMPQAX, $0x123 //检查m0.tls[0]的值是否是通过线程本地存储存入的0x123来验证tls功能是否正常
JEQ 2(PC)
CALLruntime·abort(SB) //如果线程本地存储不能正常工作，退出程序
</code></pre></td></tr></table>
</div>
</div><p>这段代码首先调用settls函数初始化主线程的线程本地存储(TLS)，<strong>目的是把m0与主线程关联在一起</strong>。设置了线程本地存储之后接下来的几条指令在于验证TLS功能是否正常，如果不正常则直接abort退出程序。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">runtime/sys_linx_amd64.s : 658

// set tls base to DI
TEXT runtime·settls(SB),NOSPLIT,$32
//......
//DI寄存器中存放的是m.tls[0]的地址，m的tls成员是一个数组，读者如果忘记了可以回头看一下m结构体的定义
//下面这一句代码把DI寄存器中的地址加8，为什么要+8呢，主要跟ELF可执行文件格式中的TLS实现的机制有关
//执行下面这句指令之后DI寄存器中的存放的就是m.tls[1]的地址了
ADDQ$8, DI// ELF wants to use -8(FS)

  //下面通过arch_prctl系统调用设置FS段基址
MOVQDI, SI //SI存放arch_prctl系统调用的第二个参数
MOVQ$0x1002, DI// ARCH_SET_FS //arch_prctl的第一个参数
MOVQ$SYS_arch_prctl, AX //系统调用编号
SYSCALL
CMPQAX, $0xfffffffffffff001
JLS2(PC)
MOVL$0xf1, 0xf1 // crash //系统调用失败直接crash
RET
</code></pre></td></tr></table>
</div>
</div><p>这里通过arch_prctl系统调用把m0.tls[1]的地址设置成了fs段的段基址。CPU中有个叫fs的段寄存器与之对应，而每个线程都有自己的一组CPU寄存器值，操作系统在把线程调离CPU运行时会帮我们把所有寄存器中的值保存在内存中，调度线程起来运行时又会从内存中把这些寄存器的值恢复到CPU，这样，在此之后，工作线程代码就可以通过fs寄存器来找到m.tls，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">// runtime/asm_amd64.s : 194

ok:
   // set the per-goroutine and per-mach &#34;registers&#34;
   get_tls(BX)    //获取fs段基址到BX寄存器
   LEAQ   runtime·g0(SB), CX //CX = g0的地址
   MOVQ   CX, g(BX)  //把g0的地址保存在线程本地存储里面，也就是m0.tls[0]=&amp;g0
   LEAQ   runtime·m0(SB), AX //AX = m0的地址

   // save m-&gt;g0 = g0
   MOVQ   CX, m_g0(AX)
   // save m0 to g0-&gt;m
   MOVQ   AX, g_m(CX)
</code></pre></td></tr></table>
</div>
</div><p>把m0和g0绑定在一起，这样，之后在主线程中通过get_tls可以获取到g0，通过g0的m成员又可以找到m0，于是这里就实现了m0和g0与主线程之间的关联。从这里还可以看到，保存在主线程本地存储中的值是g0的地址，也就是说工作线程的私有全局变量其实是一个指向g的指针而不是指向m的指针，目前这个指针指向g0，表示代码正运行在g0栈。此时，主线程，m0，g0以及g0的栈之间的关系如下图所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">   ┌───m0───────────────┐                  ┌────────────────────┐          
   │                    │                  │▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
   │                    │                  │▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
   │                    │                  │▨▨▨▨▨▨▨kernel▨▨▨▨▨▨▨│          
   │       ......       │                  │▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
   │                    │                  │▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
   │                    │                  ├────────────────────┼─────┬─   
   │                    │                  │□□□□□□□□□□□□□□□□□□□□│     │    
   ├────────────────────┤                  │□□□□□□□......□□□□□□□│     │main
   │       tls[1]       │                  │□□□□□□□□□□□□□□□□□□□□│    thread
   ├────────────────────┤&lt;-fs              ├────────────────────┤     stack
┏━━│       tls[0]       │                  │    argv[...]       │◀─┐  │    
┃  ├────────────────────┤                  ├────────────────────┤  │  │    
┣━━│         g0         │◀━┓               │       argc         │  │  │    
┃  └────────────────────┘  ┃               ├────────────────────┤  │  │    
┃                          ┃               │       ......       │  │  │    
┃  ┌───g0───────────────┐  ┃               ├────────────────────┤  │  │    
┃  │                    │  ┃               │       argv         │──┘  │    
┃  │                    │  ┃               ├────────────────────┤     ▼    
┃  │                    │  ┃               │       argc         │          
┃  │       ......       │  ┃               ├────────────────────┤          
┃  │                    │  ┃               │                    │          
┃  │                    │  ┃               ├────────────────────┤          
┃  │                    │  ┃               │                    │          
┃  ├────────────────────┤  ┃ ┏━━━━━━━━━━━━━▶────────────────────┤&lt;-sp      
┃  │         m          │━━┛ ┃             │                    │          
┃  ├────────────────────┤    ┃             │  64 * 1024 - 104   │          
┃  │    stackguard1     │━━━━╋━━━━┓        │      bytes         │          
┃  ├────────────────────┤    ┃    ┃        │                    │          
┃  │    stackguard0     │━━━━╋━━━━┫        │                    │          
┃  ├────────────────────┤    ┃    ┣━━━━━━━━▶────────────────────┘          
┃  │     stack.hi       │━━━━┛    ┃                                        
┃  ├────────────────────┤         ┃                                        
┃  │     stack.lo       │━━━━━━━━━┛                                        
┗━━▶────────────────────┘                                                  
</code></pre></td></tr></table>
</div>
</div><h2 id="初始化m0">初始化m0</h2>
<p>osinit函数获取CPU核的数量并保存在全局变量ncpu之中，调度器初始化时需要知道当前系统有多少个CPU核。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">//runtime/asm_amd64.s : 
//准备调用args函数，前面四条指令把参数放在栈上
MOVL16(SP), AX// AX = argc
MOVLAX, 0(SP)       // argc放在栈顶
MOVQ24(SP), AX// AX = argv
MOVQAX, 8(SP)       // argv放在SP + 8的位置
CALLruntime·args(SB)  //处理操作系统传递过来的参数和env，不需要关心

//对于linx来说，osinit唯一功能就是获取CPU的核数并放在global变量ncpu中，
//调度器初始化时需要知道当前系统有多少CPU核
CALLruntime·osinit(SB)  //执行的结果是全局变量 ncpu = CPU核数
CALLruntime·schedinit(SB) //调度系统初始化
</code></pre></td></tr></table>
</div>
</div><p>接下来继续看调度器是如何初始化的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runtime/proc.go : 540
</span><span class="c1"></span>

<span class="kd">func</span> <span class="nf">schedinit</span><span class="p">()</span> <span class="p">{</span>
<span class="c1">// raceinit must be the first call to race detector.
</span><span class="c1">// In particular, it must be done before mallocinit below calls racemapshadow.
</span><span class="c1"></span>   
    <span class="c1">//getg函数在源代码中没有对应的定义，由编译器插入类似下面两行代码
</span><span class="c1"></span>    <span class="c1">//get_tls(CX)
</span><span class="c1"></span>    <span class="c1">//MOVQ g(CX), BX; BX存器里面现在放的是当前g结构体对象的地址
</span><span class="c1"></span>    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">// _g_ = &amp;g0
</span><span class="c1"></span>
    <span class="o">......</span>

    <span class="c1">//设置最多启动10000个操作系统线程，也是最多10000个M
</span><span class="c1"></span>    <span class="nx">sched</span><span class="p">.</span><span class="nx">maxmcount</span> <span class="p">=</span> <span class="mi">10000</span>

    <span class="o">......</span>
   
    <span class="nf">mcommoninit</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">)</span> <span class="c1">//初始化m0，因为从前面的代码我们知道g0-&gt;m = &amp;m0
</span><span class="c1"></span>
    <span class="o">......</span>

    <span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nf">nanotime</span><span class="p">())</span>
    <span class="nx">procs</span> <span class="o">:=</span> <span class="nx">ncpu</span>  <span class="c1">//系统中有多少核，就创建和初始化多少个p结构体对象
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">atoi32</span><span class="p">(</span><span class="nf">gogetenv</span><span class="p">(</span><span class="s">&#34;GOMAXPROCS&#34;</span><span class="p">));</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">procs</span> <span class="p">=</span> <span class="nx">n</span> <span class="c1">//如果环境变量指定了GOMAXPROCS，则创建指定数量的p
</span><span class="c1"></span>    <span class="p">}</span>
    <span class="k">if</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">procs</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span><span class="c1">//创建和初始化全局变量allp
</span><span class="c1"></span>        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unknown runnable goroutine during bootstrap&#34;</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="o">......</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>前面我们已经看到，g0的地址已经被设置到了线程本地存储之中，schedinit通过getg函数（getg函数是编译器实现的，我们在源代码中是找不到其定义的）从线程本地存储中获取当前正在运行的g，这里获取出来的是g0，然后调用mcommoninit函数对m0(g0.m)进行必要的初始化，对m0初始化完成之后调用procresize初始化系统需要用到的p结构体对象，按照go语言官方的说法，p就是processor的意思，它的数量决定了最多可以有都少个goroutine同时并行运行。schedinit函数除了初始化m0和p，还设置了全局变量sched的maxmcount成员为10000，限制最多可以创建10000个操作系统线程出来工作。</p>
<p>这里我们需要重点关注一下mcommoninit如何初始化m0以及procresize函数如何创建和初始化p结构体对象。首先我们深入到mcommoninit函数中一探究竟。这里需要注意的是不只是初始化的时候会执行该函数，在程序运行过程中如果创建了工作线程，也会执行它，所以我们会在函数中看到加锁和检查线程数量是否已经超过最大值等相关的代码。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runtime/proc.go : 651
</span><span class="c1"></span>
<span class="kd">func</span> <span class="nf">mcommoninit</span><span class="p">(</span><span class="nx">mp</span> <span class="o">*</span><span class="nx">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span> <span class="c1">//初始化过程中_g_ = g0
</span><span class="c1"></span>
    <span class="c1">// g0 stack won&#39;t make sense for user (and is not necessary unwindable).
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">_g_</span> <span class="o">!=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span> <span class="p">{</span>  <span class="c1">//函数调用栈traceback，不需要关心
</span><span class="c1"></span>        <span class="nf">callers</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">createstack</span><span class="p">[:])</span>
    <span class="p">}</span>

    <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span><span class="o">+</span><span class="mi">1</span> <span class="p">&lt;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span> <span class="p">{</span>
        <span class="nf">throw</span><span class="p">(</span><span class="s">&#34;runtime: thread ID overflow&#34;</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">mp</span><span class="p">.</span><span class="nx">id</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span>
    <span class="nx">sched</span><span class="p">.</span><span class="nx">mnext</span><span class="o">++</span>
    <span class="nf">checkmcount</span><span class="p">()</span> <span class="c1">//检查已创建系统线程是否超过了数量限制（10000）
</span><span class="c1"></span>
    <span class="c1">//random初始化
</span><span class="c1"></span>    <span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1597334677</span> <span class="o">*</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
    <span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nf">cputicks</span><span class="p">())</span>
    <span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">0</span><span class="p">]|</span><span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="nx">mp</span><span class="p">.</span><span class="nx">fastrand</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
    <span class="p">}</span>

    <span class="c1">//创建用于信号处理的gsignal，只是简单的从堆上分配一个g结构体对象,然后把栈设置好就返回了
</span><span class="c1"></span>    <span class="nf">mpreinit</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">gsignal</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
    <span class="p">}</span>

    <span class="c1">//把m挂入全局链表allm之中
</span><span class="c1"></span>    <span class="c1">// Add to allm so garbage collector doesn&#39;t free g-&gt;m
</span><span class="c1"></span>    <span class="c1">// when it is just in a register or thread-local storage.
</span><span class="c1"></span>    <span class="nx">mp</span><span class="p">.</span><span class="nx">alllink</span> <span class="p">=</span> <span class="nx">allm</span>

    <span class="c1">// NumCgoCall() iterates over allm w/o schedlock,
</span><span class="c1"></span>    <span class="c1">// so we need to publish it safely.
</span><span class="c1"></span>    <span class="nf">atomicstorep</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allm</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">))</span>
    <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>

    <span class="c1">// Allocate memory to hold a cgo traceback if the cgo call crashes.
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">iscgo</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;solaris&#34;</span> <span class="o">||</span> <span class="nx">GOOS</span> <span class="o">==</span> <span class="s">&#34;windows&#34;</span> <span class="p">{</span>
        <span class="nx">mp</span><span class="p">.</span><span class="nx">cgoCallers</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">cgoCallers</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个函数把m0放入全局链表allm之中。</p>
<h2 id="初始化allp">初始化allp</h2>
<p>procresize函数，考虑到初始化完成之后用户代码还可以通过 GOMAXPROCS()函数调用它重新创建和初始化p结构体对象，而在运行过程中再动态的调整p牵涉到的问题比较多，所以这个函数的处理比较复杂，但如果只考虑初始化，相对来说要简单很多，所以这里只保留了初始化时会执行的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runtime/proc.go : 4382
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">nprocs</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">p</span> <span class="p">{</span>
    <span class="nx">old</span> <span class="o">:=</span> <span class="nx">gomaxprocs</span> <span class="c1">//系统初始化时 gomaxprocs = 0
</span><span class="c1"></span>
    <span class="o">......</span>

    <span class="c1">// Grow allp if necessary.
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">nprocs</span> <span class="p">&gt;</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">allp</span><span class="p">))</span> <span class="p">{</span> <span class="c1">//初始化时 len(allp) == 0
</span><span class="c1"></span>        <span class="c1">// Synchronize with retake, which could be running
</span><span class="c1"></span>        <span class="c1">// concurrently since it doesn&#39;t run on a P.
</span><span class="c1"></span>        <span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">nprocs</span> <span class="o">&lt;=</span> <span class="nb">int32</span><span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">allp</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">allp</span> <span class="p">=</span> <span class="nx">allp</span><span class="p">[:</span><span class="nx">nprocs</span><span class="p">]</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">//初始化时进入此分支，创建allp 切片
</span><span class="c1"></span>            <span class="nx">nallp</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">nprocs</span><span class="p">)</span>
            <span class="c1">// Copy everything up to allp&#39;s cap so we
</span><span class="c1"></span>            <span class="c1">// never lose old allocated Ps.
</span><span class="c1"></span>            <span class="nb">copy</span><span class="p">(</span><span class="nx">nallp</span><span class="p">,</span> <span class="nx">allp</span><span class="p">[:</span><span class="nb">cap</span><span class="p">(</span><span class="nx">allp</span><span class="p">)])</span>
            <span class="nx">allp</span> <span class="p">=</span> <span class="nx">nallp</span>
        <span class="p">}</span>
        <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allpLock</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c1">// initialize new P&#39;s
</span><span class="c1"></span>    <span class="c1">//循环创建nprocs个p并完成基本初始化
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">nprocs</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">pp</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="nx">pp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">pp</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span><span class="c1">//调用内存分配器从堆上分配一个struct p
</span><span class="c1"></span>            <span class="nx">pp</span><span class="p">.</span><span class="nx">id</span> <span class="p">=</span> <span class="nx">i</span>
            <span class="nx">pp</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pgcstop</span>
            <span class="o">......</span>
            <span class="nf">atomicstorep</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">pp</span><span class="p">))</span>
        <span class="p">}</span>

        <span class="o">......</span>
    <span class="p">}</span>

    <span class="o">......</span>

    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>  <span class="c1">// _g_ = g0
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">id</span> <span class="p">&lt;</span> <span class="nx">nprocs</span> <span class="p">{</span><span class="c1">//初始化时m0-&gt;p还未初始化，所以不会执行这个分支
</span><span class="c1"></span>        <span class="c1">// continue to use the current P
</span><span class="c1"></span>        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Prunning</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">mcache</span><span class="p">.</span><span class="nf">prepareForSweep</span><span class="p">()</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="c1">//初始化时执行这个分支
</span><span class="c1"></span>        <span class="c1">// release the current P and acquire allp[0]
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span><span class="c1">//初始化时这里不执行
</span><span class="c1"></span>            <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="p">}</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mcache</span> <span class="p">=</span> <span class="kc">nil</span>
        <span class="nx">p</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nx">p</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="mi">0</span>
        <span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pidle</span>
        <span class="nf">acquirep</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="c1">//把p和m0关联起来，其实是这两个strct的成员相互赋值
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
            <span class="nf">traceGoStart</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
   
    <span class="c1">//下面这个for 循环把所有空闲的p放入空闲链表
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">runnablePs</span> <span class="o">*</span><span class="nx">p</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">nprocs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
        <span class="nx">p</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="o">==</span> <span class="nx">p</span> <span class="p">{</span><span class="c1">//allp[0]跟m0关联了，所以是不能放任
</span><span class="c1"></span>            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="nx">p</span><span class="p">.</span><span class="nx">status</span> <span class="p">=</span> <span class="nx">_Pidle</span>
        <span class="k">if</span> <span class="nf">runqempty</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span><span class="c1">//初始化时除了allp[0]其它p全部执行这个分支，放入空闲链表
</span><span class="c1"></span>            <span class="nf">pidleput</span><span class="p">(</span><span class="nx">p</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="o">......</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="o">......</span>
   
    <span class="k">return</span> <span class="nx">runnablePs</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个函数代码比较长，但并不复杂，这里总结一下这个函数的主要流程：</p>
<ol>
<li>使用make([]*p, nprocs)初始化全局变量allp，即allp = make([]*p, nprocs)</li>
<li>循环创建并初始化nprocs个p结构体对象并依次保存在allp切片之中</li>
<li>把m0和allp[0]绑定在一起，即m0.p = allp[0], allp[0].m = m0</li>
<li>把除了allp[0]之外的所有p放入到全局变量sched的pidle空闲队列之中</li>
</ol>
<p>到此m0, g0, 和m需要的p完全关联在一起了。这时整个调度器相关的各组成部分之间的联系如下图所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">   ┌────┬────allp───────┐            ┌───m0───────────────┐                                             
┏━━│[0] │    ......     │            │                    │                                             
┃  └────┴───────────────┘            │                    │                                             
┃                                    │                    │                                             
┃                                    │       ......       │             ┌────────────────────┐          
┃                                    │                    │             │▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
┃                                    │                    │             │▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
┃  ┌───p────────────────┐            │                    │             │▨▨▨▨▨▨▨kernel▨▨▨▨▨▨▨│          
┃  │                    │            ├────────────────────┤             │▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
┃  │                    │      ┏━━━━━│         p          │             │▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
┃  │                    │      ┃     ├────────────────────┤             ├────────────────────┼─────┬─   
┃  │                    │      ┃     │       ......       │             │□□□□□□□□□□□□□□□□□□□□│     │    
┃  │                    │      ┃     ├────────────────────┤             │□□□□□□□......□□□□□□□│     │main
┃  │      ......        │      ┃     │       tls[1]       │             │□□□□□□□□□□□□□□□□□□□□│    thread
┃  │                    │      ┃     ├────────────────────┤&lt;-fs         ├────────────────────┤     stack
┃  │                    │      ┃  ┏━━│       tls[0]       │             │    argv[...]       │◀─┐  │    
┃  │                    │      ┃  ┃  ├────────────────────┤             ├────────────────────┤  │  │    
┃  │                    │      ┃  ┣━━│         g0         │◀━┓          │       argc         │  │  │    
┃  │                    │     ┏╋━━╋━▶└────────────────────┘  ┃          ├────────────────────┤  │  │    
┃  │                    │     ┃┃  ┃                          ┃          │       ......       │  │  │    
┃  ├────────────────────┤     ┃┃  ┃  ┌───g0───────────────┐  ┃          ├────────────────────┤  │  │    
┃  │         m          │━━━━━┛┃  ┃  │                    │  ┃          │       argv         │──┘  │    
┃  ├────────────────────┤      ┃  ┃  │                    │  ┃          ├────────────────────┤     ▼    
┃  │      ......        │      ┃  ┃  │                    │  ┃          │       argc         │          
┗━━▶────────────────────◀━━━━━━┛  ┃  │       ......       │  ┃          ├────────────────────┤          
                                  ┃  │                    │  ┃          │                    │          
                                  ┃  │                    │  ┃          ├────────────────────┤          
                                  ┃  │                    │  ┃          │                    │          
                                  ┃  ├────────────────────┤  ┃ ┏━━━━━━━━▶────────────────────┤&lt;-sp      
                                  ┃  │         m          │━━┛ ┃        │                    │          
                                  ┃  ├────────────────────┤    ┃        │  64 * 1024 - 104   │          
                                  ┃  │    stackguard1     │━━━━╋━┓      │      bytes         │          
                                  ┃  ├────────────────────┤    ┃ ┃      │                    │          
                                  ┃  │    stackguard0     │━━━━╋━┫      │                    │          
                                  ┃  ├────────────────────┤    ┃ ┣━━━━━━▶────────────────────┘          
                                  ┃  │     stack.hi       │━━━━┛ ┃                                      
                                  ┃  ├────────────────────┤      ┃                                      
                                  ┃  │     stack.lo       │━━━━━━┛                                      
                                  ┗━━▶────────────────────┘                                             
</code></pre></td></tr></table>
</div>
</div><h1 id="创建main-goroutine">创建main goroutine</h1>
<p>schedinit完成调度系统初始化后，返回到rt0_go函数中开始调用newproc() 创建一个新的goroutine用于执行mainPC所对应的runtime·main函数，看下面的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">// runtime/asm_amd64.s : 219
// create a new goroutine to start program
MOVQ  $runtime·mainPC(SB), AX // entry，mainPC是runtime.main
// newproc的第二个参数入栈，也就是新的goroutine需要执行的函数
PUSHQ  AX          // AX = &amp;funcval{runtime·main},

// newproc的第一个参数入栈，该参数表示runtime.main函数需要的参数大小，因为runtime.main没有参数，所以这里是0
PUSHQ  $0
CALL  runtime·newproc(SB) // 创建main goroutine
POPQ  AX
POPQ  AX

// start this M
CALL  runtime·mstart(SB)  // 主线程进入调度循环，运行刚刚创建的goroutine

// 上面的mstart永远不应该返回的，如果返回了，一定是代码逻辑有问题，直接abort
CALL  runtime·abort(SB)// mstart should never return
RET

DATA  runtime·mainPC+0(SB)/8,$runtime·main(SB)
GLOB  Lruntime·mainPC(SB),RODATA,$8
</code></pre></td></tr></table>
</div>
</div><p>newproc函数用于创建新的goroutine，它有两个参数，先说第二个参数fn，新创建出来的goroutine将从fn这个函数开始执行，而这个fn函数可能也会有参数，newproc的第一个参数正是fn函数的参数以字节为单位的大小。比如有如下go代码片段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">start</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">......</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">go</span> <span class="nf">start</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>编译器在编译上面的go语句时，就会把其替换为对newproc函数的调用，编译后的代码逻辑上等同于下面的伪代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">push</span> <span class="mh">0x3</span>
    <span class="nx">push</span> <span class="mh">0x2</span>
    <span class="nx">push</span> <span class="mh">0x1</span>
    <span class="nx">runtime</span><span class="p">.</span><span class="nf">newproc</span><span class="p">(</span><span class="mi">24</span><span class="p">,</span> <span class="nx">start</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>那为什么需要传递fn函数的参数大小给newproc函数呢？原因就在于<strong>newproc函数将创建一个新的goroutine来执行fn函数</strong>，而这个<strong>新创建的goroutine与当前这个goroutine会使用不同的栈</strong>，因此就<!-- raw HTML omitted -->需要在创建goroutine的时候把fn需要用到的参数先从当前goroutine的栈上拷贝到新的goroutine的栈上之后才能让其开始执行<!-- raw HTML omitted -->，而newproc函数本身并不知道需要拷贝多少数据到新创建的goroutine的栈上去，所以需要用参数的方式指定拷贝多少数据。</p>
<p>newproc函数是对newproc1的一个包装，这里最重要的准备工作有两个，一个是获取fn函数第一个参数的地址（代码中的argp），另一个是使用systemstack函数切换到g0栈，当然，对于我们这个初始化场景来说现在本来就在g0栈，所以不需要切换，然而这个函数是通用的，在用户的goroutine中也会创建goroutine，这时就需要进行栈的切换。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runtime/proc.go : 3570
</span><span class="c1"></span>
<span class="c1">// Create a new g running fn with siz bytes of arguments.
</span><span class="c1">// Put it on the queue of g&#39;s waiting to run.
</span><span class="c1">// The compiler turns a go statement into a call to this.
</span><span class="c1">// Cannot split the stack because it assumes that the arguments
</span><span class="c1">// are available sequentially after &amp;fn; they would not be
</span><span class="c1">// copied if a stack split occurred.
</span><span class="c1">//go:nosplit
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newproc</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//函数调用参数入栈顺序是从右向左，而且栈是从高地址向低地址增长的
</span><span class="c1"></span>    <span class="c1">//注意：argp指向fn函数的第一个参数，而不是newproc函数的参数
</span><span class="c1"></span>    <span class="c1">//参数fn在栈上的地址+8的位置存放的是fn函数的第一个参数
</span><span class="c1"></span>    <span class="nx">argp</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fn</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
    <span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>  <span class="c1">//获取正在运行的g，初始化时是m0.g0
</span><span class="c1"></span>   
    <span class="c1">//getcallerpc()返回一个地址，也就是调用newproc时由call指令压栈的函数返回地址，
</span><span class="c1"></span>    <span class="c1">//对于我们现在这个场景来说，pc就是CALLruntime·newproc(SB)指令后面的POPQ AX这条指令的地址
</span><span class="c1"></span>    <span class="nx">pc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
   
    <span class="c1">//systemstack的作用是切换到g0栈执行作为参数的函数
</span><span class="c1"></span>    <span class="c1">//我们这个场景现在本身就在g0栈，因此什么也不做，直接调用作为参数的函数
</span><span class="c1"></span>    <span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">newproc1</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="kt">uint8</span><span class="p">)(</span><span class="nx">argp</span><span class="p">),</span> <span class="nx">siz</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>newproc1函数的第一个参数fn是新创建的goroutine需要执行的函数，注意这个fn的类型是funcval结构体类型，其定义如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">funcval</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">fn</span> <span class="kt">uintptr</span>
    <span class="c1">// variable-size, fn-specific data here
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>newproc1的第二个参数argp是fn函数的第一个参数的地址，第三个参数是fn函数的参数以字节为单位的大小，后面两个参数我们不用关心。这里需要注意的是，newproc1是在g0的栈上执行的。该函数很长也很重要，所以我们分段来看。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// runtime/proc.go : 3601
</span><span class="c1"></span>
<span class="c1">// Create a new g running fn with narg bytes of arguments starting
</span><span class="c1">// at argp. callerpc is the address of the go statement that created
</span><span class="c1">// this. The new g is put on the queue of g&#39;s waiting to run.
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">newproc1</span><span class="p">(</span><span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">,</span> <span class="nx">argp</span> <span class="o">*</span><span class="kt">uint8</span><span class="p">,</span> <span class="nx">narg</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">callergp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//因为已经切换到g0栈，所以无论什么场景都有 _g_ = g0，当然这个g0是指当前工作线程的g0
</span><span class="c1"></span>    <span class="c1">//对于我们这个场景来说，当前工作线程是主线程，所以这里的g0 = m0.g0
</span><span class="c1"></span>    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

    <span class="o">......</span>

    <span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span> <span class="c1">//初始化时_p_ = g0.m.p，从前面的分析可以知道其实就是allp[0]
</span><span class="c1"></span>    <span class="nx">newg</span> <span class="o">:=</span> <span class="nf">gfget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="c1">//从p的本地缓冲里获取一个没有使用的g，初始化时没有，返回nil
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">newg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
         <span class="c1">//new一个g结构体对象，然后从堆上为其分配栈，并设置g的stack成员和两个stackgard成员
</span><span class="c1"></span>        <span class="nx">newg</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="nx">_StackMin</span><span class="p">)</span>
        <span class="nf">casgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">_Gidle</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">)</span> <span class="c1">//初始化g的状态为_Gdead
</span><span class="c1"></span>         <span class="c1">//放入全局变量allgs切片中
</span><span class="c1"></span>        <span class="nf">allgadd</span><span class="p">(</span><span class="nx">newg</span><span class="p">)</span> <span class="c1">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack.
</span><span class="c1"></span>    <span class="p">}</span>
   
    <span class="o">......</span>
   
    <span class="c1">//调整g的栈顶置针，无需关注
</span><span class="c1"></span>    <span class="nx">totalSize</span> <span class="o">:=</span> <span class="mi">4</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">RegSize</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">MinFrameSize</span> <span class="c1">// extra space in case of reads slightly beyond frame
</span><span class="c1"></span>    <span class="nx">totalSize</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">totalSize</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">SpAlign</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>                  <span class="c1">// align to spAlign
</span><span class="c1"></span>    <span class="nx">sp</span> <span class="o">:=</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">totalSize</span>
    <span class="nx">spArg</span> <span class="o">:=</span> <span class="nx">sp</span>

    <span class="c1">//......
</span><span class="c1"></span>   
    <span class="k">if</span> <span class="nx">narg</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
         <span class="c1">//把参数从执行newproc函数的栈（初始化时是g0栈）拷贝到新g的栈
</span><span class="c1"></span>        <span class="nf">memmove</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">spArg</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">argp</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">narg</span><span class="p">))</span>
        <span class="c1">// ......
</span><span class="c1"></span>    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这段代码主要从堆上分配一个g结构体对象并为这个newg分配一个大小为2048字节的栈，并设置好newg的stack成员，然后把newg需要执行的函数的参数从执行newproc函数的栈（初始化时是g0栈）拷贝到newg的栈，完成这些事情之后newg的状态如下图所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">   ┌────┬────allp───────┐            ┌───m0───────────────┐                                             
┏━━│[0] │    ......     │            │                    │                                             
┃  └────┴───────────────┘            │                    │                                             
┃                                    │                    │                                             
┃                                    │       ......       │             ┌────────────────────┐          
┃                                    │                    │             │▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
┃                                    │                    │             │▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
┃  ┌───p────────────────┐            │                    │             │▨▨▨▨▨▨▨kernel▨▨▨▨▨▨▨│          
┃  │                    │            ├────────────────────┤             │▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
┃  │                    │      ┏━━━━━│         p          │             │▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│          
┃  │                    │      ┃     ├────────────────────┤             ├────────────────────┼─────┬─   
┃  │                    │      ┃     │       ......       │             │□□□□□□□□□□□□□□□□□□□□│     │    
┃  │                    │      ┃     ├────────────────────┤             │□□□□□□□......□□□□□□□│     │main
┃  │      ......        │      ┃     │       tls[1]       │             │□□□□□□□□□□□□□□□□□□□□│    thread
┃  │                    │      ┃     ├────────────────────┤&lt;-fs         ├────────────────────┤     stack
┃  │                    │      ┃  ┏━━│       tls[0]       │             │    argv[...]       │◀─┐  │    
┃  │                    │      ┃  ┃  ├────────────────────┤             ├────────────────────┤  │  │    
┃  │                    │      ┃  ┣━━│         g0         │◀━┓          │       argc         │  │  │    
┃  │                    │     ┏╋━━╋━▶└────────────────────┘  ┃          ├────────────────────┤  │  │    
┃  │                    │     ┃┃  ┃                          ┃          │       ......       │  │  │    
┃  ├────────────────────┤     ┃┃  ┃  ┌───g0───────────────┐  ┃          ├────────────────────┤  │  │    
┃  │         m          │━━━━━┛┃  ┃  │                    │  ┃          │       argv         │──┘  │    
┃  ├────────────────────┤      ┃  ┃  │                    │  ┃          ├────────────────────┤     ▼    
┗━▶│      ......        │      ┃  ┃  │                    │  ┃          │       argc         │          
   └────────────────────◀━━━━━━┛  ┃  │       ......       │  ┃          ├────────────────────┤          
                                  ┃  │                    │  ┃          │                    │          
                                  ┃  │                    │  ┃          ├────────────────────┤          
                                  ┃  │                    │  ┃          │                    │          
                                  ┃  ├────────────────────┤  ┃ ┏━━━━━━━━▶────────────────────┤          
                                  ┃  │         m          │━━┛ ┃        │   &amp;funcval{        │          
   ┌───newg─────────────┐         ┃  ├────────────────────┤    ┃        │    runtime·main}   │          
   │                    │         ┃  │    stackguard1     │━━━━╋━┓      ├────────────────────┤          
   │                    │         ┃  ├────────────────────┤    ┃ ┃      │         0          │          
   │                    │         ┃  │    stackguard0     │━━━━╋━┫      ├────────────────────┤          
   │       ......       │         ┃  ├────────────────────┤    ┃ ┃      │   return address   │          
   │                    │         ┃  │     stack.hi       │━━━━┛ ┃      │   of newproc       │          
   │                    │         ┃  ├────────────────────┤      ┃      ├────────────────────┤&lt;-sp      
   │                    │         ┗━▶│     stack.lo       │━━━━━━┫      │                    │          
   ├────────────────────┤            └────────────────────┘      ┃      │       ......       │          
   │       m=nil        │                                        ┃      │                    │          
   ├────────────────────┤                                        ┗━━━━━━▶────────────────────┤          
   │    stackguard1     │                                                       ......                 
   ├────────────────────┤               ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━▶────────────────────┤     ▲    
   │    stackguard0     │━━━━━━━━━━━━━━━╋━━━━━━━┓                       │                    │     │    
   ├────────────────────┤               ┃       ┃                       │                    │     │    
   │     stack.hi       │━━━━━━━━━━━━━━━┛       ┃                       │     newg stack     │   heap   
   ├────────────────────┤                       ┣━━━━━━━━━━━━━━━━━━━━━━━▶────────────────────┤     │    
   │     stack.lo       │━━━━━━━━━━━━━━━━━━━━━━━┛                       │▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨▨│     │    
   └────────────────────┘                                               └────────────────────┴─────┴─   
</code></pre></td></tr></table>
</div>
</div><p>程序中多了一个我们称之为newg的g结构体对象，该对象也已经获得了从堆上分配而来的2k大小的栈空间，newg的stack.hi和stack.lo分别指向了其栈空间的起止位置。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">//把newg.sched结构体成员的所有成员设置为0
</span><span class="c1"></span>    <span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">))</span>
   
    <span class="c1">//设置newg的sched成员，调度器需要依靠这些字段才能把goroutine调度到CPU上运行。
</span><span class="c1"></span>    <span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>  <span class="c1">//newg的栈顶
</span><span class="c1"></span>    <span class="nx">newg</span><span class="p">.</span><span class="nx">stktopsp</span> <span class="p">=</span> <span class="nx">sp</span>
    <span class="c1">//newg.sched.pc表示当newg被调度起来运行时从这个地址开始执行指令
</span><span class="c1"></span>    <span class="c1">//把pc设置成了goexit这个函数偏移1（sys.PCQuantum等于1）的位置，
</span><span class="c1"></span>    <span class="c1">//至于为什么要这么做需要等到分析完gostartcallfn函数才知道
</span><span class="c1"></span>    <span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">goexit</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PCQuantum</span> <span class="c1">// +PCQuantum so that previous instruction is in same function
</span><span class="c1"></span>    <span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newg</span><span class="p">))</span>

    <span class="nf">gostartcallfn</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span> <span class="c1">//调整sched成员和newg的栈
</span></code></pre></td></tr></table>
</div>
</div><p>&hellip;</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">schedule()-&gt;execute()-&gt;gogo()-&gt;g2()-&gt;goexit()-&gt;goexit1()-&gt;mcall()-&gt;goexit0()-&gt;schedule()
</code></pre></td></tr></table>
</div>
</div><p>每个工作线程的执行流程和调度循环都一样，如下图所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">                       ┌──────────────────┐                                               
                       │     mstart()     │                                               
                       └──────────────────┘                                               
                                 │                                                        
                                 ▼                                                        
                       ┌──────────────────┐                                               
                       │     mstart1()    │                                               
                       └──────────────────┘                                               
                                 │                                                        
                                 │                                                        
                                 │                                                        
┌────────────scheduling loop─────┼──────────────────┐              ┌──────g0 stack────┐   
│                                ▼                  │              │     ......       │   
│                      ┌──────────────────┐         │              ├──────────────────┤   
│          ┌──────────▶│    schedule()    │─ ─ ─ ─ ─│─ ─ ─ ─ ─ ─ ─▶│ mstart stack     │   
│          │           └──────────────────┘         │              ├──────────────────┤   
│          │                     │                  │              │ mstart1 stack    │◀─┐
│          │                     ▼                  │              ├──────────────────┤  │
│          │           ┌──────────────────┐         │              │ schedule stack   │  │
│          │           │     execule()    │         │              ├──────────────────┤  │
│          │           └──────────────────┘         │              │ execute stack    │  │
│          │                     │                  │              ├──────────────────┤  │
│          │                     │                  │              │ gogo stack       │  │
│          │                     ▼                  │              └──────────────────┘  │
│ ┌────────────────┐   ┌──────────────────┐         │                                    │
│ │ other runtime  │   │      gogo()      │         │                                    │
│ │  functions     │   └──────────────────┘         │                                    │
│ └────────────────┘             │                  │                                    │
│          ▲                     │                  │              ┌────────g0────────┐  │
│          │                     ▼                  │              │                  │  │
│          │           ┌──────────────────┐         │              ├──────────────────┤  │
│          │           │ user goroutine   │         │              │     ......       │  │
│          │           └──────────────────┘         │              ├──────────────────┤  │
│          │                     │                  │              │     sched.sp     │──┘
│          │                     │                  │              ├──────────────────┤   
│          │                     ▼                  │              │     ......       │   
│          │           ┌──────────────────┐         │              └──────────────────┘   
│          └───────────│     mcall()      │         │                                     
│                      └──────────────────┘         │                                     
│                                                   │                                     
└───────────────────────────────────────────────────┘                                     
</code></pre></td></tr></table>
</div>
</div><p>工作线程的执行流程：</p>
<ol>
<li>初始化，调用mstart函数；</li>
<li>调用mstart1函数，在该函数中调用save函数设置g0.sched.sp和g0.sched.pc等调度信息，其中g0.sched.sp指向mstart函数栈帧的栈顶；</li>
<li>依次调用schedule-&gt;execute-&gt;gogo函数执行调度；</li>
<li>运行用户的goroutine代码；</li>
<li>用户goroutine代码执行过程中调用runtime中的某些函数，然后这些函数调用mcall切换到g0.sched.sp所指的栈并最终再次调用schedule函数进入新一轮调度，之后工作线程一直循环执行着3～5这一调度循环直到进程退出为止。</li>
</ol>
<h1 id="gpm-的状态流转">GPM 的状态流转</h1>
<p>G 的状态流转：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">┌──────────┐                                                      
│  _Gidle  │                                                      
└──────────┘                                                      
      │                             ┌───────────────────────┐     
   newproc                          │                       │     
      │                             ▼                       │     
      ▼                       ┏━━━━━━━━━━┓──────────┐       │     
┌──────────┐                  ┃          ┃          │       │     
│  _Gdead  │◀──────goexit─────┃_Grunning ┃◀─┐       │       │     
└──────────┘                  ┃          │  │       │       │     
      │                       ┗━━━━━━━━━━┫  │       │       │     
      │                             │    │  │       │       │     
  newproc       ┌──────────┐    park_m   │  │       │       │     
      │         │_Gwaiting │◀───────┘    │  │     enter    exit   
      ▼         └──────────┘             │  │    syscall syscall  
┏━━━━━━━━━━┓          │                  │  │       │       │     
┃          ┃          │                  │  │       │       │     
┃_Grunnable┃◀───ready─┘                  │  │       │       │     
┃          ┃                             │  │       │       │     
┗▲━━━━━━━━━┛◀─────────────Gosched────────┘  │       │       │     
 │    │                                     │       │       │     
 │    │                                     │       │       │     
 │    └──────────────execute────────────────┘       │       │     
 │                                                  ▼       │     
 │              exit                          ┌──────────┐  │     
 └────────────syscall0────────────────────────│_Gsyscall │──┘     
                                              └──────────┘        
</code></pre></td></tr></table>
</div>
</div><p>P 的状态流转：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">	                                                            
     ┌──────────────startTheWorld─────────────┐             
     │                                        │             
     │                                        ▼             
┌────────┐                               ┌─────────┐        
│        │◀ ─ ─ ─ ─ ─ ─GC ─ ─ ─ ─ ─ ─ ─ ─│         │        
│_Pgcstop│                               │_Prunning│◀─┐     
│        │◀ ─ ─ ─GC ─ ─ ─   ┌─acquirep──▶│         │  │     
└────────┘               │  │            └┬────────┘  │     
     ▲  │                   │             │   │       │     
        │              ┌─┴──┴─┐           │   │       │     
     │  │              │      │  releasep │ enter    exit   
        └─procresize──▶│_Pidle│◀──retake──┘syscall syscall  
     │                 │      │               │       │     
                       └──────┘               │       │     
     │                     ▲                  ▼       │     
                           │             ┌─────────┐  │     
     │                     └───retake────┤         │  │     
      ─ ─ ─ ─GC ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─│_Psyscall│──┘     
                                         │         │        
                                         └─────────┘        
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>通常情况下（在程序运行时不调整 P 的个数），P 只会在上图中的四种状态下进行切换。当程序刚开始运行进行初始化时，所有的 P 都处于 <code>_Pgcstop</code> 状态， 随着 P 的初始化（ <code>runtime.procresize</code>），会被置于 <code>_Pidle</code>。</p>
<p>当 M 需要运行时，会 <code>runtime.acquirep</code> 来使 P 变成 <code>Prunning</code> 状态，并通过 <code>runtime.releasep</code> 来释放。</p>
<p>当 G 执行时需要进入系统调用，P 会被设置为 <code>_Psyscall</code>， 如果这个时候被系统监控抢占（ <code>runtime.retake</code>），则 P 会被重新修改为 <code>_Pidle</code>。</p>
<p>如果在程序运行中发生 <code>GC</code>，则 P 会被设置为 <code>_Pgcstop</code>， 并在 <code>runtime.startTheWorld</code> 时重新调整为 <code>_Prunning</code>。</p>
</blockquote>
<p>M 的状态变化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"> ┌────────┐                   ┌────────────┐
 │spinning│───G not found────▶│non-spinning│
 └────────┘       GC          └────────────┘
      ▲                              │      
      │                              │      
      │                              │      
      │                              ▼      
┌──────────┐                    ┌─────────┐ 
│notewakeup│◀────by other M─────│notesleep│ 
└──────────┘                    └─────────┘ 
</code></pre></td></tr></table>
</div>
</div><h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="https://mp.weixin.qq.com/s/n6LLhtGwVcCurgk8wP4q8Q">源码游记-goroutine调度器系列</a></li>
</ul>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Kiyon Lin</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
      2020-12-04
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://kiyonlin.github.io/tags/golang/">golang</a>
          <a href="https://kiyonlin.github.io/tags/scheduler/">scheduler</a>
          <a href="https://kiyonlin.github.io/tags/runtime/">runtime</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/plans/2021/">
            
            <i class="iconfont">
              <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

            </i>
            <span class="prev-text nav-default">2021年度计划</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/plans/%E8%8B%B1%E8%AF%AD%E8%A7%84%E5%88%92/">
            <span class="next-text nav-default">英语学习规划</span>
            <span class="prev-text nav-mobile">下一篇</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  

  
  

  

  
  
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "kiyonlin/kiyonlin.github.io"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:kiyonlin@163.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
  
  
  
  
  
    <a href="https://github.com/kiyonlin" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>
  
  
    <a href="https://www.zhihu.com/people/kiyonlin" rel="me noopener" class="iconfont"
      title="zhihu"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M351.791182 562.469462l192.945407 0c0-45.367257-21.3871-71.939449-21.3871-71.939449L355.897709 490.530013c3.977591-82.182744 7.541767-187.659007 8.816806-226.835262l159.282726 0c0 0-0.86367-67.402109-18.578124-67.402109s-279.979646 0-279.979646 0 16.850783-88.141456 39.318494-127.053698c0 0-83.60514-4.510734-112.121614 106.962104S81.344656 355.077018 76.80834 367.390461c-4.536316 12.313443 24.62791 5.832845 36.941354 0 12.313443-5.832845 68.050885-25.924439 84.252893-103.69571l86.570681 0c1.165546 49.28652 4.596691 200.335724 3.515057 226.835262L109.86113 490.530013c-25.275663 18.147312-33.701566 71.939449-33.701566 71.939449L279.868105 562.469462c-8.497535 56.255235-23.417339 128.763642-44.275389 167.210279-33.05279 60.921511-50.55235 116.65793-169.802314 212.576513 0 0-19.442818 14.257725 40.829917 9.073656 60.273758-5.185093 117.305683-20.739347 156.840094-99.807147 20.553105-41.107233 41.805128-93.250824 58.386782-146.138358l-0.055259 0.185218 167.855986 193.263655c0 0 22.035876-51.847855 5.832845-108.880803L371.045711 650.610918l-42.1244 31.157627-0.045025 0.151449c11.69946-41.020252 20.11206-81.5749 22.726607-116.858498C351.665315 564.212152 351.72876 563.345412 351.791182 562.469462z"></path>
  <path d="M584.918753 182.033893l0 668.840094 70.318532 0 28.807093 80.512708 121.875768-80.512708 153.600307 0L959.520453 182.033893 584.918753 182.033893zM887.150192 778.934538l-79.837326 0-99.578949 65.782216-23.537066-65.782216-24.855084 0L659.341766 256.673847l227.807403 0L887.149169 778.934538z"></path>
</svg>

    </a>
  
  
  
  
  
  
  
  
  
  


<a href="https://kiyonlin.github.io/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2016 -
    2021
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        Kiyon Lin
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  















</body>
</html>
