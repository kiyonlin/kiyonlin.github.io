---
title: "Fasthttp系列——解析请求头"
date: 2020-08-21T19:16:54+08:00
lastmod: 2020-08-25T15:30:41+08:00
tags: [golang, fasthttp]
categories: [golang, fasthttp]
---
> 本系列通过解析`fasthttp`([v1.16.0](https://github.com/valyala/fasthttp/tree/v1.16.0))源码学习[HTTP/1.1](https://httpwg.org/specs/rfc7230.html)。

## 前言
[上一篇文章](https://kiyonlin.github.io/post/work/fasthttp/01fh%E8%AF%B7%E6%B1%82%E8%A1%8C/)我们学习了`HTTP/1.1`的请求行(`Request Line`)，下面我们继续学习请求头的解析。

## 请求头格式
`HTTP/1.1`的[消息格式](https://httpwg.org/specs/rfc7230.html#http.message)如下：
  
```text
  HTTP-message   = start-line
                   *( header-field CRLF )
                   CRLF
                   [ message-body ]
```

- start-line: 起始行
- *( header-field CRLF ): 头字段+分隔符(`\r\n`)
- CRLF: 空行
- \[ message-body \]: 可选的消息体

所有`HTTP/1.1`消息均包含一个起始行，其后是一系列头字段，由分隔符(`\r\n`)隔开，接着是一个**空行**(`\r\n`)，最后是可选的消息体。

[上一篇文章](https://kiyonlin.github.io/post/work/fasthttp/01fh%E8%AF%B7%E6%B1%82%E8%A1%8C/)学习的请求行就是起始行的一种，还有一种是[状态行(Status Line)](https://httpwg.org/specs/rfc7230.html#status.line)，我们会在之后讲解。

我们可以发现，每一个头字段后面都需要跟随一个分隔符(`\r\n`)，**当某一行只有分隔符(`\r\n`)时**，就意味着请求头数据已发送完毕。使用[httpie](https://httpie.org/)就可以轻松查看一个真实的请求头数据：
```bash
$ http "www.baidu.com" -p H
# 请求行
GET / HTTP/1.1
# 请求头
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host: www.baidu.com
User-Agent: HTTPie/1.0.3

```

## 解析请求头
我们再来看看`fasthttp`是如何解析请求头的。当`fasthttp`读取到完整的请求头数据后，开始解析请求头，并返回请求头的字节数：

```go
func (h *RequestHeader) parse(buf []byte) (int, error) {
	m, err := h.parseFirstLine(buf)
	if err != nil {
		return 0, err
	}

	h.rawHeaders, _, err = readRawHeaders(h.rawHeaders[:0], buf[m:])
	if err != nil {
		return 0, err
	}
	var n int
	n, err = h.parseHeaders(buf[m:])
	if err != nil {
		return 0, err
	}
	return m + n, nil
}
```

我们看到了熟悉的`parseFirstLine`，解析请求行，接着继续读取并保存请求头的原始数据`h.rawHeaders, _, err = readRawHeaders(h.rawHeaders[:0], buf[m:])`。在`readRawHeaders`中我们可以看到([完整源码](https://github.com/valyala/fasthttp/blob/v1.16.0/header.go#L1760-L1786))：
```go
func readRawHeaders(dst, buf []byte) ([]byte, int, error) {
	n := bytes.IndexByte(buf, '\n')
	if (n == 1 && buf[0] == '\r') || n == 0 {
		// empty headers
		return dst, n + 1, nil
	}
	for {
		m = bytes.IndexByte(b, '\n')
		// ...
		m++
		// ...
		if (m == 2 && b[0] == '\r') || m == 1 {
			// ...
			return dst, n, nil
		}
	}
}
```

目的就是找到单独的`\r\n`或者`\n`，一旦找到，就表示没有更多的请求头数据了。从源码中我们可以发现*`fasthttp`兼容了以`\n`作为分隔符的数据格式*。

最后是解析请求头信息`n, err = h.parseHeaders(buf[m:])`，解析成功后，返回第一行数据和请求头的总字节数。`parseHeaders`的[代码](https://github.com/valyala/fasthttp/blob/v1.16.0/header.go#L1868-L1952)比较长，就不再全部贴出来。

`fasthttp`在解析请求头时，使用了[headerScanner](https://github.com/valyala/fasthttp/blob/v1.16.0/header.go#L1985-L2005)这个结构体，调用[next](https://github.com/valyala/fasthttp/blob/v1.16.0/header.go#L2007-L2114)方法一行一行解析。

针对指定的头字段：[Host](#Host)，[UserAgent](#UserAgent)，[Content-Type](#ContentType)，[Content-Length](#ContentLength)，[Connection](#Connection)和[Transfer-Encoding](#TransferEncoding)，`fasthttp`会做一些特殊操作，我们会一一进行解析。其他头字段信息会存入`h.h`([源码](https://github.com/valyala/fasthttp/blob/v1.16.0/header.go#L70))中：`h.h = appendArgBytes(h.h, s.key, s.value, argsHasValue)`。

我们先深入分析`headerScanner.next()`。

### 头字段
首先我们看看[头字段](https://httpwg.org/specs/rfc7230.html#header.fields)的结构：
```text
  header-field   = field-name ":" OWS field-value OWS

  field-name     = token
  field-value    = *( field-content / obs-fold )
  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
  field-vchar    = VCHAR / obs-text

  obs-fold       = CRLF 1*( SP / HTAB )
                 ; obsolete line folding
                 ; see Section 3.2.4
```

每个头字段均由不区分大小写的字段名，后跟冒号(`:`)，可选的前导空白(`OWS`)，字段值和可选的尾随空白(`OWS`)组成。

> 注：`OWS`指的是`optional whitespace`，[详情链接](https://httpwg.org/specs/rfc7230.html#whitespace)。

`fasthttp`的[headerScanner](https://github.com/valyala/fasthttp/blob/v1.16.0/header.go#L1985-L2005)就是头部扫描器，负责扫描请求头数据，解析出头字段的字段名(`key`)和字段值(`value`)，每次调用`next()`都解析一行数据。

根据标准，头字段名称紧跟着一个`:`，所以需要根据`:`的位置确认头字段名称的值。这里`fasthttp`加了一个[处理](https://github.com/valyala/fasthttp/blob/v1.16.0/header.go#L2039-L2043)：`:`之前不能有`\n`，因为此时这个头字段肯定是非法的。

解析出头字段名称后，`fasthttp`根据[配置](https://github.com/valyala/fasthttp/blob/v1.16.0/server.go#L315-L331)看需不需要标准化头名称，`normalizeHeaderKey(s.key, s.disableNormalizing)`，这是为了统一客户端发送的请求头字段名称格式，防止出现类似`cONTENT-lenGTH`的字段名而在使用时无法匹配的情况。

一般情况下，每个头字段的值在一行内，但是也有可能放在多行里(obs-fold)，举个例子：
```text
# 一行
Header: value1, value2

# 多行
Header: value1,
        value2
```

这两种格式的值是等价的，想深入了解的可以查看[这里](https://stackoverflow.com/questions/31237198/is-it-possible-to-include-multiple-crlfs-in-a-http-header-field)。`fasthttp`也[兼容](https://github.com/valyala/fasthttp/blob/v1.16.0/header.go#L2071-L2112)了这种情况，然后对多行值进行格式化`s.value, s.b, s.hLen = normalizeHeaderValue(s.value, oldB, s.hLen)`。

最终获取到`s.key`和`s.value`。

### 处理头字段键值对
获取到头字段键值对后，对于一般的头字段，`fasthttp`将他们存储在`h.h []argsKV`切片中(`h.h = appendArgBytes(h.h, s.key, s.value, argsHasValue)`)，`argsKV`具体结构如下：
```go
type argsKV struct {
	key     []byte
	value   []byte
	noValue bool
}
```

为什么不直接存在`map`中呢？我们之后会讲解，主要是为了**延迟解析**以及**内存复用**。现在就想知道原因的可以查看[youtu.be 13:42](https://youtu.be/ghKCFvSNQkQ?t=822)。

接下来我们讲讲几个特殊的头字段，以及`fasthttp`对它们的处理。不过在此之前，我们需要看懂这行代码：
```go
switch s.key[0] | 0x20
```

翻译一下就是将`s.key[0]`，即头字段名称的首字母，转为小写。原理也很简单，用一段代码解释：
```go
A := 0b01000001
a := 0b01100001
x := 0b00100000 // 0x20
println(A|x == a) // true
println(a|x == a) // true
```

#### Host
`Host`头字段([详情](https://httpwg.org/specs/rfc7230.html#header.host))提供了目标`URI`的主机和端口信息，使服务器能够区分资源，同时为单个`IP`地址上的多个主机名的请求提供服务。`Host`具有指定的格式：
```text
  Host = uri-host [ ":" port ] ; Section 2.7.1
```

**`RFC7230`中指明`Host`是必须字段**。若`Host`不合法(未提供，提供多个，格式非法)，服务端必须响应`400 Bad Request`。

通过`caseInsensitiveCompare(s.key, strHost)`比较头字段名称和常量`strHost`，确定是否将其存入请求头的`host`字段：`h.host = append(h.host[:0], s.value...)`。

> 注：`caseInsensitiveCompare`也用到了`0x20`的技巧([源码](https://github.com/valyala/fasthttp/blob/v1.16.0/cookie.go#L538-L550))。

#### UserAgent
`User-Agent`头字段([详情](https://httpwg.org/specs/rfc7231.html#header.user-agent))包含有关发起请求的用户代理的信息，服务器通常使用该信息来帮助识别报告的互操作性问题的范围，解决或调整响应以避免特定的用户代理限制以及进行分析有关浏览器或操作系统的使用。用户代理应该在每个请求中发送一个`User-Agent`字段。

它的结构如下：
```text
  User-Agent = product *( RWS ( product / comment ) )
```

该字段的值直接存入请求头的`userAgent`字段中。

#### ContentType
`Content-Type`头字段([详情](https://httpwg.org/specs/rfc7231.html#header.content-type))指定了请求的[媒体类型](https://httpwg.org/specs/rfc7231.html#media.type)。

常见的例子有：
```text
  Content-Type: text/html; charset=ISO-8859-4
  Content-Type: application/json; charset=utf-8
```

该字段的值直接存入请求头的`contentType`字段中。

#### ContentLength
当请求中没有[Transfer-Encoding](https://httpwg.org/specs/rfc7230.html#header.transfer-encoding)头字段时，可以设置[Content-Length](https://httpwg.org/specs/rfc7230.html#header.content-length)头字段，为潜在的消息体提供预期的大小（八位字节的十进制数）；若包含[Transfer-Encoding](https://httpwg.org/specs/rfc7230.html#header.transfer-encoding)头字段，则**无法**设置`Content-Length`。

`fasthttp`使用`parseContentLength`([源码](https://github.com/valyala/fasthttp/blob/v1.16.0/header.go#L1974-L1983))解析具体的数值，并[处理](https://github.com/valyala/fasthttp/blob/v1.16.0/bytesconv.go#L189-L192)了溢出的情况，避免了[通过协议元素长度产生的攻击](https://httpwg.org/specs/rfc7230.html#attack.protocol.element.length)。

若解析成功，`fasthttp`也会将原始的字节数据保存在`h.contentLengthBytes = append(h.contentLengthBytes[:0], s.value...)`中。

#### Connection
`Connection`头字段([详情](https://httpwg.org/specs/rfc7230.html#header.connection))允许客户端控制当前连接。

*`Connection`值是不区分大小写的*，所以`fasthttp`使用`bytes.Equal(s.value, strClose)`来比较连接值是否为常量`strClose("close")`，并保存到`connectionClose`字段中，同时将原始的字节数据保存在`h.h = appendArgBytes(h.h, s.key, s.value, argsHasValue)`中。

#### TransferEncoding
`Transfer-Encoding`头字段([详情](https://httpwg.org/specs/rfc7230.html#header.transfer-encoding))列出与已经（或将要）应用于有效载荷主体以形成消息主体的传输编码序列相对应的传输编码名称。传输编码在[这里](https://httpwg.org/specs/rfc7230.html#transfer.codings)定义，有兴趣的读者可以自行了解。

我们看看`fasthttp`的处理逻辑：
```go
if !bytes.Equal(s.value, strIdentity) {
	h.contentLength = -1
	h.h = setArgBytes(h.h, strTransferEncoding, strChunked, argsHasValue)
}
```

因为`identity`已经被[移除](https://httpwg.org/specs/rfc7230.html#changes.from.rfc.2616)，所以`fasthttp`忽略了`identity`，且根据我们在[Content-Length](#ContentLength)中学到的知识，此时应该忽略`contentLength`，所以将其设为`-1`，对应了`Content-Length`头字段的`if h.contentLength != -1 {...}`([源码](https://github.com/valyala/fasthttp/blob/v1.16.0/header.go#L1901-L1911))处理。最后把`Transfer-Encoding`头字段的值设为`chunked`。

### 收尾操作
解析完所有的头字段后，`fasthttp`进行了一些收尾操作：
```go
if h.contentLength < 0 {
	h.contentLengthBytes = h.contentLengthBytes[:0]
}
if h.noHTTP11 && !h.connectionClose {
	// close connection for non-http/1.1 request unless 'Connection: keep-alive' is set.
	v := peekArgBytes(h.h, strConnection)
	h.connectionClose = !hasHeaderValue(v, strKeepAlive)
}
```

1. 未设置`h.contentLength`时，清空`h.contentLengthBytes`
1. 不是`HTTP/1.1`的情况下重新设置`h.connectionClose`的值(排除`Connection: keep-alive`的情况)

## 总结
请求头解析部分到这里就告一段落了，我们学习了不少请求头相关的知识，稍微总结：
- 每个请求头是根据分隔符(`\r\n`)分隔的，但可以包含多行值
- 空行代表请求头数据的终止
- 一些具体的请求头概念
- 使用`scanner`解析数据流
- 字母字符比较时使用`0x20`的小技巧

*敬请期待之后的系列文章！* 👋
