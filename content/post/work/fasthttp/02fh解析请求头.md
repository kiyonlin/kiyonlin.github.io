---
title: "Fasthttp系列——解析请求头"
date: 2020-08-21T19:16:54+08:00
lastmod: 2020-08-21T19:16:59+08:00
tags: [golang, fasthttp]
categories: [golang, fasthttp]
draft: true
---
> 本系列通过解析`fasthttp`([v1.16.0](https://github.com/valyala/fasthttp/tree/v1.16.0))源码学习[HTTP/1.1](https://httpwg.org/specs/rfc7230.html)。

## 前言
[上一篇文章](https://kiyonlin.github.io/post/work/fasthttp/01fh%E8%AF%B7%E6%B1%82%E8%A1%8C/)我们学习了`HTTP/1.1`的请求行(`Request Line`)，下面我们继续学习请求头的解析。

## 请求头格式
`HTTP/1.1`的[消息格式](https://httpwg.org/specs/rfc7230.html#http.message)如下：
  
```text
  HTTP-message   = start-line
                   *( header-field CRLF )
                   CRLF
                   [ message-body ]
```

- start-line: 起始行
- *( header-field CRLF ): 头字段+分隔符(`\r\n`)
- CRLF: 空行
- \[ message-body \]: 可选的消息体

所有`HTTP/1.1`消息均包含一个起始行，其后是一系列头字段，由分隔符(`\r\n`)隔开，接着是一个**空行**(`\r\n`)，最后是可选的消息体。

[上一篇文章](https://kiyonlin.github.io/post/work/fasthttp/01fh%E8%AF%B7%E6%B1%82%E8%A1%8C/)学习的请求行就是起始行的一种，还有一种是[状态行(Status Line)](https://httpwg.org/specs/rfc7230.html#status.line)，我们会在之后讲解。

我们可以发现，每一个头字段后面都需要跟随一个分隔符(`\r\n`)，**当某一行只有分隔符(`\r\n`)时**，就意味着请求头数据已发送完毕。使用[httpie](https://httpie.org/)就可以轻松查看一个真实的请求头数据：
```bash
$ http "www.baidu.com" -p H
# 请求行
GET / HTTP/1.1
# 请求头
Accept: */*
Accept-Encoding: gzip, deflate
Connection: keep-alive
Host: www.baidu.com
User-Agent: HTTPie/1.0.3

```

## 解析请求头
我们再来看看`fasthttp`是如何解析请求头的。当`fasthttp`读取到完整的请求头数据后，开始解析请求头，并返回请求头的字节数：

```go
func (h *RequestHeader) parse(buf []byte) (int, error) {
	m, err := h.parseFirstLine(buf)
	if err != nil {
		return 0, err
	}

	h.rawHeaders, _, err = readRawHeaders(h.rawHeaders[:0], buf[m:])
	if err != nil {
		return 0, err
	}
	var n int
	n, err = h.parseHeaders(buf[m:])
	if err != nil {
		return 0, err
	}
	return m + n, nil
}
```

我们看到了熟悉的`parseFirstLine`，解析请求行，接着继续读取并保存请求头的原始数据`h.rawHeaders, _, err = readRawHeaders(h.rawHeaders[:0], buf[m:])`。在`readRawHeaders`中我们可以看到([完整源码](https://github.com/valyala/fasthttp/blob/v1.16.0/header.go#L1760-L1786))：
```go
func readRawHeaders(dst, buf []byte) ([]byte, int, error) {
	n := bytes.IndexByte(buf, '\n')
	if (n == 1 && buf[0] == '\r') || n == 0 {
		// empty headers
		return dst, n + 1, nil
	}
	for {
		m = bytes.IndexByte(b, '\n')
		// ...
		m++
		// ...
		if (m == 2 && b[0] == '\r') || m == 1 {
			dst = append(dst, buf[:n]...)
			return dst, n, nil
		}
	}
}
```

目的就是找到单独的`\r\n`或者`\n`，一旦找到，就表示没有更多的请求头数据了。从源码中我们可以发现*`fasthttp`兼容了以`\n`作为分隔符的数据格式*。

最后是解析请求头信息`n, err = h.parseHeaders(buf[m:])`，解析成功后，返回第一行数据和请求头的总字节数。`parseHeaders`的[代码](https://github.com/valyala/fasthttp/blob/v1.16.0/header.go#L1868-L1952)比较长，就不再全部贴出来。

`fasthttp`在解析请求头时，使用了[headerScanner](https://github.com/valyala/fasthttp/blob/v1.16.0/header.go#L1985-L2005)这个结构体，调用[next](https://github.com/valyala/fasthttp/blob/v1.16.0/header.go#L2007-L2114)方法一行一行解析。

针对指定的头字段：`Host`，`UserAgent`，`ContentType`，`ContentLength`，`Connection`和`Transfer-Encoding`，`fasthttp`会做一些特殊操作，我们会一一进行解析。其他头字段信息会存入`h.h`([源码](https://github.com/valyala/fasthttp/blob/v1.16.0/header.go#L70))中：`h.h = appendArgBytes(h.h, s.key, s.value, argsHasValue)`。

我们先来`headerScanner.next()`。

### `headerScanner.next()`

## 总结

*敬请期待之后的系列文章！* 👋
