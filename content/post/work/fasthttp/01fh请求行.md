---
title: "Fasthttp系列——请求行"
date: 2020-08-18T14:08:37+08:00
lastmod: 2020-08-18T14:08:42+08:00
tags: [golang, fasthttp]
categories: [golang, fasthttp]
---
> 本系列通过解析`fasthttp`([v1.16.0](https://github.com/valyala/fasthttp/tree/v1.16.0))源码学习[HTTP/1.1](https://httpwg.org/specs/rfc7230.html)。

## 第一行
`WEB`服务接收`HTTP`请求要做的第一件事，就是解析请求行([Request Line](https://httpwg.org/specs/rfc7230.html#request.line))。它的格式如下：

```text
request-line   = method SP request-target SP HTTP-version CRLF
```

- method: [请求方法](#请求方法)
- SP: 空格
- request-target: [请求目标](#请求目标)
- HTTP-version: `HTTP`版本
- CRLF: 分隔符`\r\n`

对应到`fasthttp`中的[代码](https://github.com/valyala/fasthttp/blob/v1.16.0/header.go#L1696-L1727)是：
```go
func (h *RequestHeader) parseFirstLine(buf []byte) (int, error) {
	bNext := buf
	var b []byte
	var err error
	for len(b) == 0 {
		if b, bNext, err = nextLine(bNext); err != nil {
			return 0, err
		}
	}

	// parse method
	n := bytes.IndexByte(b, ' ')
	if n <= 0 {
		return 0, fmt.Errorf("cannot find http request method in %q", buf)
	}
	h.method = append(h.method[:0], b[:n]...)
	b = b[n+1:]

	// parse requestURI
	n = bytes.LastIndexByte(b, ' ')
	if n < 0 {
		h.noHTTP11 = true
		n = len(b)
	} else if n == 0 {
		return 0, fmt.Errorf("requestURI cannot be empty in %q", buf)
	} else if !bytes.Equal(b[n+1:], strHTTP11) {
		h.noHTTP11 = true
	}
	h.requestURI = append(h.requestURI[:0], b[:n]...)

	return len(buf) - len(bNext), nil
}
```

我们可以看到`fasthttp`先调用[nextLine](https://github.com/valyala/fasthttp/blob/v1.16.0/header.go#L2158-L2167)方法，根据分隔符(`\r\n`)获取出第一行的所有字节数据`b`。

再根据`b`中第一个空格字节的位置解析出`method`，存入请求头对象中`h.method = append(h.method[:0], b[:n]...)`。

再根据`b`中最后一个空格的位置，解析出`request-target`和`HTTP-version`。

其中`HTTP-version`由`h.noHTTP11`保存一个`bool`值，不存在`HTTP`版本数据或者它不等于`HTTP/1.1`时，这个字段都为`false`。

而`request-target`也是直接保存到请求头对象中`h.requestURI = append(h.requestURI[:0], b[:n]...)`。

最后返回第一行的字节数，done！

## 请求方法
> The method token indicates the request method to be performed on the target resource. The request method is case-sensitive.

我们注意到`RFC`中有提到请求`method`是大小写敏感的(`The request method is case-sensitive`)。

而且根据上面的解析过程，我们可以看出`fasthttp`获取到`method`时，直接保存在请求头中，并没有做任何检查。所以当请求端发送了不正确(比如用了小写)的`method`值时，服务端可以拒绝这次请求(`400 Bad Request`)。

所有的请求`method`可以在[RFC7231](https://httpwg.org/specs/rfc7231.html#methods)中查看，之后也会细讲。

## 请求目标
客户端发送`HTTP`请求消息时，其中包含从目标`URI`派生的请求目标。请求目标有四种不同的格式，具体取决于请求的方法以及请求是否针对代理：

```text
  request-target = origin-form
                 / absolute-form
                 / authority-form
                 / asterisk-form
```

之后的文章会针对请求目标做详细的分析，这里不再赘述。

## 总结
本系列的第一篇文章就这样结束了。我们了解了请求行的结构，并剖析了`fasthttp`是如何从数据流中解析这第一行请求数据。

*敬请期待之后的系列文章！* 👋
